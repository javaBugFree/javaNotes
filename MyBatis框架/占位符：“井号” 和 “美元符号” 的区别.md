
所有的SQL语句在*执行之前*，**必须编译**，在*编译之前*，**必须经过词法分析、语义分析**。

- Mybatis中的 `#{}` 格式的占位符 **是** *预编译* 的。
    - 即SQL语句会 *先经过* 语法分析、语义分析，再编译，编译完成后，*再将* 值代入到编译结果中一并执行！
        - 由于是预编译的，此前已经完成语义分析，，语义是已经确定的，占位符的位置一直是某个值，不可能是字段名，所以，**所有值都不需要使用单引号框住**！
        - 并且，由于是预编译的，所以**不存在SQL注入的问题**！使用这种占位符时，*占位符位置* **只能表示某个值**！
            - 即先`name = ?`来检查SQL是否正确、哪种类型，然后才代入值`name = 相册001`

- Mybatis中的 `￥{}` 格式的占位符 **不是** *预编译* 的。
    - 即 *先将* 值代入到SQL语句中，然后，将代入后的结果 *再* 执行语法分析、语义分析，编译，最终执行！
        - 由于不是预编译的，而是先将值 代入到SQL语句中，对于 *非数值、非布尔值* 的其他值而言，*如果不加单引号，就会被误以为是字段名*，所以，**所有非数值、非布尔值的其他值都必须使用一对单引号框住**！
        - 并且，由于不是预编译的，向SQL语句中传入的值有可能改变SQL的语义，是**存在SQL注入风险**的！使用这种占位符时，*占位符位置* **可以表示SQL语句的任何片段**！

*SQL注入代码示例：*
```sql
SQL:                                 root                 123456
SELECT * FROM user WHERE username = 'root' AND password = 123456;

SQL:                                 root                 1' or 'x' = 'x
SELECT * FROM user WHERE username = 'root' AND password = '1' OR 'x' = 'x';
```



## 筛选条件要不要加 (‘’) 单引号

例如：
```sql
SELECT COUNT(*) FROM pms_album WHERE name = '相册001'
SELECT COUNT(*) FROM pms_album WHERE name = 相册001
```

在一个 SQL语句中，除了Mybatis认识的(SELECT、FROM等)，还有一些确定的(SELECT后的字段、数据表等)，其他都会被认为是列的名称（例如相册001）。