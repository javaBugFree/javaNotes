
- **抽象方法的声明原则**：
    - *返回值类型*：如果要执行的数据访问操作，是 **增、删、改** 类型的，使用 `int` 作为返回值，表示 *受影响的行数*。
        - 如果 *不关心受影响的行数* ，也可以使用 `void` 作为返回值，但并*不推荐*。
        - 如果要执行数据访问操作是 **查询类型** 的，只要保证返回值类型能够 **放得下** 查询结果即可。
        - **提示：** *非统计类型* 的**查询**，一般*不建议使用 实体类* 来接收数据，应该使用其他**POJO类型**，《阿里巴巴Java开发手册》提供的参考：
        ```text
        1） 数据对象：xxxDO，xxx 即为数据表名。 
        2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 
        3） 展示对象：xxxVO，xxx 一般为网页名称。 
        4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。
        ```
        - 另外，关于POJO的后缀，**必须每个字母都是 大写的**，《阿里巴巴Java开发手册》强制规定：
        ```text
        【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO 
        正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 
        反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion
        ```
    - *方法名称*：自定义。根据《阿里巴巴Java开发手册》提供的*参考*：
    ```text
    A) Service/DAO 层方法命名规约
	    1） 获取单个对象的方法用 get 做前缀。 
	    2） 获取多个对象的方法用 list 做前缀。 
	    3） 获取统计值的方法用 count 做前缀。 
	    4） 插入的方法用 save/insert 做前缀。 
	    5） 删除的方法用 remove/delete 做前缀。 
	    6） 修改的方法用 update 做前缀。
    ```
    - *参数列表*：取决于要执行的**SQL语句中有哪些参数**，如果参数的数量*超过1个*，且具有明确的相关性，建议使用封装的类型（*DTO*）作为抽象方法的参数，
        - 通常，插入单条数据、修改数据时，都使用实体类作为抽象方法的参数
        - 如果涉及**批量数据操作**，例如批量删除、批量更新、批量插入等，可以使用*数组、可变参数 或  `List`集合* 表示若干个参数值。


<hr>


- **关于XML文件的内部配置：**
    1. 根标签必须是 `<mapepr>`，且此标签必须配置 `namespace` 属性，取值为*映射的接口*的 **全限定名（包名+类名）**。
    
    2. 在根标签的的子级，可以使用 `<insert>` / `<delete>` / `<update>` / `<select>` 这些标签来配置 增、删、改、查对应的SQL语句，这些标签都必须配置 `id属性`，取值为*mapper接口*中*映射的抽象方法名*。
        - 其实，`<update>` 和 `<delete>` 这2个标签可以随意调换使用，
          例如，配置`DELETE`语句可以使用`<update>`标签，甚至，在不考虑获取自动编号的ID时，`<insert>`标签和`<update>`、`<delete>`也可以随意调用使用，
          因为这3种数据访问操作在 **JDBC的底层实现是一样的**，当然，这种乱用的方式肯定是*非常不建议*的。
       
    3. 在`<insert>...`这4种标签的子级，编写SQL语句，**参数部分**使用 `#{名称}` 格式的*占位符*来表示。其中，占位符中的 **名称** 应该是*参数名称*，或*封装类型中的 属性名*。
        - 严格来说，在`#{}`格式的占位符中的名称，将被用于生成 Setter 和 Getter 的名称，然后，Mybatis框架会自动调用相关方法。
    
    4. 如果配置的是`<insert>`标签，并且插入数据的表的**主键是自动编号的**。应该在此标签上配置：`useGeneratedKeys="true"` 和 `keyProperty="主键属性"` 这2个属性，以获取自动编号的ID值
        - `keyProperty="id"`：把主键值返回给 *类里的id属性*。
    
    5. 如果涉及**批量操作**，需要通过`<\foreach>`标签来进行*遍历 参数对象*，关于此标签的使用：
        - `collection`属性：表示被遍历的对象，
            - 当抽象方法的*参数只有1个*，且*没有添加* `@Param`注解时，
               如果参数是 **数组或可变参数**，则此属性的值为：`array`，
               如果参数是 **List集合**，则此属性的值为：`list`
            - 当抽象方法的*参数为多个*，且*需要添加* `@Param`注解，则此属性的值为：`注解的配置值`。
        - `item`属性：表示**遍历过程中** *各元素的名称*，是自定义名称，并且在`<foreach>`子级的`#{}`占位符中，也使用此名称表示被遍历到的元素。
        - `separator`属性：设置分隔符。表示遍历过程中，各值之间的分隔符号。
        - <\foreach>标签是Mybatis的 **动态SQL** 标签之一。
    
    6. 如果涉及修改数据的操作，当使用了`<if>`实现动态SQL时，通常，应该使用`<set>`标签将更新列表框住，并且，SQL语句中不需要写`SET`关键字
    
    7. 关于动态SQL的`<if>`标签，可以**对参数进行判断**，从而 *确定* SQL语句中*应该 包含 或 不包含哪些片段*，
        - 需要注意，*没有`else`标签*。如果一定要实现类似的效果，可以使用 **两个条件完全相反** 的`<if>`标签（虽然执行效率会差一些）。
          或着使用`<choose>`系列标签。语法格式如下：
            ```xml
            <choose>
	            <when test="条件">
	                满足条件时的SQL片段
	            </when>
	            <otherwise>
		            不满足条件时的SQL片段
	            </otherwise>
            </choose>
            ```
    
    8. 如果配置的是`<select>`标签，此标签必须使用 `resultType` 或 `resultMap` 这 两个属性之一。
        - 使用 `resultType`：值为 *返回值类型*。
            - 如果值为 **基本数据类型** 时：直接使用 *类型名称* 作为此属性值即可。
                例如：`<select id="count" resultType="int">`
            - 如果值为 **引用数据类型时** ：需要使用 *类型的全限定名* 来作为此属性值。
                - 例如：``resultType="com.example.xxx.User"`
                - 但当该类型是 **java.lang 包** 下的，则 *可以不写包名*。
                    - `resultType="Integer"`
        
        - 使用 `resultMap`：值为 *<\resultMap>标签的 id* 。
            - *作用*：当属性名和字段名不同时，用来对应字段和属性。
            - 对应的使用 `<resultMap>` 标签来定义 字段和属性的对应关系
                - **id 属性**：用来声明该 *resultMap* 标签的id，来和SQL语句中的`resultMap`属性 相对应。
                - **type 属性**：用来指定 *返回值类型。*
                - `<id>` 标签：用来定义 *主键字段*。
                - `<result>`标签：用来定义 **字段和VO类里属性** 的*对应关系*。
                    - **column 属性**：*字段* 的名字。
                    - **property 属性**：*类中属性* 的名字。
                    - *提示*：当 字段名和属性名相同 时，对应的标签可以省略不写。
            - 例如：
                ```xml
                <!-- AlbumStandardVo getStandardById(Long id); -->
                <select id="getStandardById" resultMap="StandardResultMap">
                    SELECT
                    <include refid="StandardQueryFields"/>
                    FROM pms_album
                    WHERE id = #{id}
                </select>
                
                <!-- 复用代码 -->  
				<sql id="StandardQueryFields">  
				    id, name, description, sort
				</sql>
                    
                <!-- id: 用来声明该 resultMap 标签的id，来和SQL语句相对应
                     type: 用来指定返回值类型
                     -->  
                <resultMap 
                    id="StandardResultMap"
                    type="cn.tedu.csmall.product.pojo.vo.AlbumStandardVO">
                    
                    <id column="id" property="id"/>
                    <!-- 两个属性相同 该标签可省略 -->
                    <result column="name" property="name"/>  
                    <result column="description" property="description"/>
                    <result column="sort" property="sort"/>
                </resultMap>
                ```

- **collection** *标签*：
    - OrderListVO 类型中包含订单项的集合，需要编写*特殊映射关系*才能顺利查询。
    - 使用 *collection标签* 来映射 *对象中的集合属性*
    - **标签属性：**
        - `property`（**必填**）：指定 *要映射的* **属性名称**。
        - `javaType`（*可选*）：指定 **集合的类型**，*默认*类型为*List*，如果匹配就*可以省略*。
            - *数组*的话就用：`javaType="java.util.Arrays"`
        - `ofType`（**必填**）：指定 **集合的泛型类型**，泛型类型就是被赋值的对象。
    - 例如：
        ```xml
        <!-- 重要！ -->  
		<!-- 查询当前登录用户指定时间范围内所有订单信息 的 resultMap --><resultMap id="OrderWithOrderItemMap" type="cn.tedu.mall.pojo.order.vo.OrderListVO">  
		    <id column="id" property="id"/>  
		    <result column="sn" property="sn"/>  
		    <result column="user_id" property="userId"/>  
		    <result column="contact_name" property="contactName"/>  
		    <result column="state" property="state"/>  
		    <result column="amount_of_actual_pay" property="amountOfActualPay"/>  
		    <result column="gmt_order" property="gmtOrder"/>  
		    <result column="gmt_pay" property="gmtPay"/>  
		    <result column="gmt_create" property="gmtCreate"/>  
		    <result column="gmt_modified" property="gmtModified"/>  
		  
		    <!-- OrderListVO 类型中包含订单项的集合，需要编写特殊映射关系才能顺利查询 -->  
		    <!-- 使用collection标签来映射 对象中的集合属性 -->  
		    <!--        属性：  
		        property(必填)：指定要映射的属性名称  
		        javaType(可选)：指定集合的类型，默认类型为List，如果匹配就可以省略。  
		            数组的话就用：javaType="java.util.Arrays"  
		        ofType(必填)：指定集合的泛型类型，泛型类型就是被赋值的对象  
		    -->  
		    <collection property="orderItems"  
		                javaType="java.util.Arrays"  
		                ofType="cn.tedu.mall.pojo.order.vo.OrderItemListVO">  
		        <id column="ooi_id" property="id"/>  
		        <result column="order_id" property="orderId"/>  
		        <result column="sku_id" property="skuId"/>  
		        <result column="title" property="title"/>  
		        <result column="price" property="price"/>  
		        <result column="quantity" property="quantity"/>  
		    </collection>  
		</resultMap>
		```


<hr>

- **关于SQL语句的编写规范**
    - 关于 **INSERT** 语句：
        - 使用`INSERT INTO`开头，不要省略 `INTO` 关键字
        - 使用`VALUES`，不要使用`VALUE`。
        - 显式地写出字段列表，不要省略
    
    - 关于 **SELECT** 语句
        - **查询数据** 时，**不允许** 使用 `*` 表示 被查询的字段列表。
            - 如果不需要查全部的数据，就会浪费时间。
            - MySQL根本**不识别** `*`，MySQL会解析数据表，然后再 转换为全部的字段列表 再 进行查询。
                - 增加查询分析器的*解析成本*。
        - **统计查询** 时，`COUNT()` 函数内**必须**使用 `*`。
        - **查询列表** 时，必须 *显式的* 使用 `ORDER BY` 指定排序规则。如果没有使用 则 排序结果不可控。
            - 并且，在使用 `ORDER BY` 指定排序规则时，如果第1排序规则无法明确地区分所有数据的顺序，还应该指定第2排序规则，甚至第3排序规则等...，*直至 所有数据 都有明确的排序规则*。