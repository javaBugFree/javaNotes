
  
当我们在浏览器注册页面**输入框中输入了中文**，并以*GET形式提交表单*，那么浏览器会将表单信息拼接  
到URL的抽象路径中。  
http://localhost:8088/regUser?username=范传奇&password=123456&...  
  
*请求的请求行:*  
请求行:GET /regUser?username=范传奇&password=123456&... HTTP/1.1  
  
HTTP协议规定*请求与响应的前两部分 都是文字*，但是**字符集必须为：** *ISO8859-1*。
而这是一个*欧洲的字符集，里面不包含中文*。因此如果以上述请求行样子传递中文则*违背了HTTP协议* 。
对于请求的要求，因此是不被允许的。  
*结论*：**中文不能被直接传递**。  
  
  
**解决办法:**  
思路：*用ISO8859-1支持的字符* 去 *表达不支持的字符*。  
ISO8859-1里，*英文，数字，符号* 都是支持的字符。  
a-z 0-9这些字符都可用。  
  
中文"范"本身在ISO8859-1中不支持。  
1. *先* 将 "范" 用支持的字符集*转换为2进制*。例如*用UTF-8编码转换为2进制*。  
  11101000  10001100  10000011  
2. 用*ISO8859-1支持的字符*中的两个字符：*'1' 和 '0' 来表达2进制*
  用字符串:"111010001000110010000011" 来表达"范"的UTF-8编码里2进制样子  
  /regUser?username=111010001000110010000011&password=xxxx&....  
  
以上方式实现了传递中文的目的。
但是**缺点：** *用24个字符来表达1个中文字符*，意味着*数据量越大传送，速度越慢*。  
  
**解决长度问题带来的传输效率低**  
思路：*用16进制来表达2进制*。因为16进制可以用字符0-9和A-F表达，这依然不违背ISO8859-1支持。  
  
二进制         十进制         十六进制  
0000            0               0  
0001            1               1  
0010            2               2  
0011            3               3  
0100            4               4  
0101            5               5  
0110            6               6  
0111            7               7  
1000            8               8  
1001            9               9  
1010            10              A  
1011            11              B  
1100            12              C  
1101            13              D  
1110            14              E  
1111            15              F  

**2进制转换16进制是以**：*每四位2进制 转换为 一个16进制*。
中文"范"的UTF-8编码2进制:11101000  10001100  10000011  
对应的16进制样子:                  E8                  8C                  83  

用字符串"E88C83"仍然可以表达中文的"范"且不违背ISO8859-1允许使用的字符  
传递时:  
/regUser?username=111010001000110010000011&password=xxxx&....  
/regUser?username=E88C83&password=xxxx&....  
  
长度问题解决了。**新问题**：*如何与 实际的英文数字组合 区分?*
例如:  
一个人注册时，英文名就叫E88C83  
/regUser?username=E88C83&password=xxxx&....  
服务端读取到用户名:"E88C83"时将其还原为2进制后再以UTF-8转换为"范"还是这人就叫"E88C83"  

**为了解决此问题**，*URL格式要求*如果想*表达16进制信息时*，*每2位 16进制前  必须添加一个"%"*  
因此如果传递: 
/regUser?username=*E88C83*&password=xxxx&....   此人名字就叫"E88C83"  
如果传递:  
/regUser?username=*%E8%8C%83*&password=xxxx&....  
此时理解位用户名是3个字节的16进制形式，要先将E8 8C 83转换为:11101000 10001100 10000011  
然后再将2进制以UTF-8还原为中文"范"  
  
**问题：** 如果我注册就叫"%E8%8C%8C"。
**结论：** 不行！*因为URL中："%"、"?"、"=" 属于关键字*，
如果使用浏览器 会将输入的"%"转换为"%XX"表达  


**UTF是Unicode Transformation Format的缩写，意为Unicode转换格式。**  
unicode中的中文"范"2进制为:10000011 00000011  

*在网络上 我们不是直接用unicode传输数据，而是用UTF传输。*
*原因：*
在Socket层面传输范对应的字节:  
客户端发送两个字节:10000011  00000011给服务端  
当服务端读取到这两个字节时要将其还原为字符时会出现*两种情况*:  
在*unicode中*每个*英文占1字节*，*中文占2字节*。  
10000011  00000011 单独看可以理解为是两个英文字符(也可能是符号或数字)  
10000011  00000011 将两个字节一起看就是中文"范"  
不知道服务端会怎么看。
  
*为了解决服务端理解问题*，因此我们会将*unicode附带 长度信息*(目的就是*让接收方理解 几个字节表达一个字符*)  
**UTF-8的规则**：
如果是*单字节表达一个字符*，那么*直接用1字节*即可。  
**2进制第一位一定为0**
例如:  
011011000  
^  
**如果2进制第一位是0**，*接收方会理解* 这就是*单独1字节*  
  
**如果2进制第一位是1**，那么*接收方就要连续看* **前4位 有几个连续的1** *表示*  **要连续读几个字节表达内容**。
例如：
          vvvv       vvvvvv  数据位  
11001100 10110010  
^^^^            ~~
所以上述1100表达 *连续读取2字节*。**后面 尾随的字节 一定是以10开始 再跟数据位**  
读取数来的字节:1100 110010  
  
  
*如果是中文*：10000011 00000011 就要用3字节表达，其中用1个字节表达长度信息。  
例如：
          vvvv      vvvvvv      vvvvvv   数据位  
1110xxxx 10xxxxxx 10xxxxxx   x的部分就是原始unicode内容  
^^^^           ~~                 ~~
*1110开始时* 接收方应当理解为 *要连续读取3个字节*  。
  
举例:  
"范"的标准unicode编码:10000011 00000011  
11101000  10001100  10000011  
E8                  8C                  83  
  
  
  
**实现：** 
在*HttpServletRequest* 的 *parseURI方法* 中，在*拆分出参数部分queryString*后，使用  
JAVA的API提供的类：*java.net.URLDecoder* 的 **decode方法  进行转码**。