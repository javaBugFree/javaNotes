
business模块是我们设计的新增订单业务的*触发者*，是**起点**。
  
它是 **单纯的消费者**。
  
我们不需要像生产者一样去创建两个子项目  
  
直接在现有项目上进行修改即可  
  
pom文件直接添加 *dubbo 和 order业务逻辑接口的依赖*：
```xml
<!-- Dubbo在SpringBoot中使用的依赖 -->  
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-dubbo</artifactId>  
</dependency>  
  
<!-- business模块要消费order模块的服务，所以要添加order模块业务逻辑层接口的依赖 -->  
<dependency>  
    <groupId>cn.tedu</groupId>  
    <artifactId>csmall-order-service</artifactId>  
    <version>0.0.1-SNAPSHOT</version>  
</dependency>
```

*application-dev.yml* 添加 **Dubbo的配置**
```yml
dubbo:  
  protocol: # 协议  
    # 在网络中只要有 通信，一定需要端口号  
    # port: -1 表示dubbo自动寻找可用端口号。  
    # 默认寻找可以端口的规则是从20880开始，可用就使用，不可用就+1，直到找到可用的为止。  
    port: -1  
    # 设置连接的名称，一般设置为 dubbo即可。  
    name: dubbo  
  registry: # 注册  
    # 指定要注册到的注册中心  
    address: nacos://localhost:8848  
  consumer:  
    # 检查：如果当前项目为消费者，检查消费到的所有服务是否启用  
    # 设置当前项目启动时，是否检查本项目 需要的 所有远程服务都已经在注册中心注册  
    # 设置它的值为false，表示不检查，以减少启动时因为需要的服务不可用导致的各种错误  
    check: false
```


我们要在当前business模块的 *业务逻辑层实现类*中，实现 **Dubbo调用** *order模块的生成订单方法*。
  
*BusinessServiceImpl*类中：
```java 
@Slf4j  
@Service  
public class BusinessServiceImpl implements BusinessService {  
  
    /*  
        Dubbo调用Order模块实现新增订单的功能  
        提交我们业务逻辑层方法中定义的orderAddDTO对象  
        business模块是单纯的消费者  
     */    @DubboReference  
    private OrderService dubboOrderService;  
  
    @Override  
    public void buy() {  
          
        // 先实例化一个要新增的订单对象  
        OrderAddDTO orderAddDTO = new OrderAddDTO();  
        orderAddDTO.setUserId("UU100");  
        orderAddDTO.setCommodityCode("PC100");  
        orderAddDTO.setCount(5);  
        orderAddDTO.setMoney(100);  
  
        // 实例化号的orderAddDTO对象，微服务结构中要传到order模块中  
        dubboOrderService.orderAdd(orderAddDTO);  
        log.info("新增的订单信息为：{}", orderAddDTO);  
    }  
  
}
```

*Springboot启动类* **不必要写** @EnableDubbo，因为business是单纯的消费者  
  
保证Nacos正在运行
再依次启动cart\stock\order  
最后启动business项目  
http://localhost:20000/doc.html 运行测试