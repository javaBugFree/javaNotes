
## 奈非框架简介(我们不用)

早期（*2020年前*）**奈非** 提供的 *微服务组件和框架* 收到了很多开发者的欢迎

*这些框架* 和 *SpringCloud Alibaba* 的 **对应关系** 我们要了解：
- 现在还有很多就项目维护是使用奈非框架完成的微服务框架
- Nacos 对应 *Eureka* 都是注册中心
- Dubbo 对应 *Ribbon+feign* 都是实现微服务远程RPC调用的组件
- Sentinel 对应 *Hystrix* 都是对项目 限流/熔断/降级的组件。
- SpringGateway 对应 *Zuul* 都是网关组件
    - SpringGateway框架部署阿里写的，是Spring提供的


## 什么是网关

“**网**” 指 *网络*，“**关**” 指 *关口或关卡*。

**网关**：就是指 *网络中的 关口/关卡*。

程序中的网关就是 *当前微服务项目 对外界开放的* **统一入口**。
所有外界的请求都需要先经过网关才能访问到我们的程序。
  
提供了统一入口之后，**方便** *对所有请求* **进行统一的检查和管理**。

![[什么是网关.png]]


网关的 **主要功能** 有：
* 将 *所有请求* **统一经过网关**；
* 网关可以对这些请求进行**检查**；
* 网关 **方便记录** 所有请求的 **日志**；
* 网关可以 *统一将所有请求* **路由到** *正确的 模块 / 服务*上。


## Spring Gateway简介  
  
我们使用Spring Gateway作为当前项目的网关框架。
Spring Gateway是Spring自己编写的，也是 *SpringCloud中的组件*。
  
Spring Gateway官网
https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/  
  
网关项目git地址
https://gitee.com/jtzhanghl/gateway-demo.git


## 简单网关演示

SpringGateway网关 **是一个依赖，不是一个软件**。
所以我们要使用它的话，必须先创建一个SpringBoot项目  

这个项目也要 *注册到Nacos* 注册中心，因为网关项目也是微服务项目的一个组成部分。
  
beijing和shanghai是编写好的两个项目，无需添加网关相关依赖，*可启动* 且 *注册到注册中心* 即可。

gateway项目就是 **网关项目**，需要 *添加相关配置*：
1. 添加*网关依赖*
```xml
<dependencies>  
    <!--   SpringGateway的依赖   -->  
    <dependency>  
        <groupId>org.springframework.cloud</groupId>  
        <artifactId>spring-cloud-starter-gateway</artifactId>  
    </dependency>  
    <!--   Nacos依赖   -->  
    <dependency>  
        <groupId>com.alibaba.cloud</groupId>  
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>  
    </dependency>  
    <!--   网关负载均衡依赖    -->  
    <dependency>  
        <groupId>org.springframework.cloud</groupId>  
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>  
    </dependency>  
</dependencies>
```

2. 开始添加 *yml文件* **配置**
```yml
server:  
  port: 9000  
spring:  
  application:  
    name: gateway  
  cloud:  
    nacos:  
      discovery:  
        server-addr: localhost:8848  
    gateway:  
      # route是路由的意思,下面内容就是开始路由配置,因为网关项目可能有多个路由信息  
      # 所以网关路由配置是一个集合routes  
      routes:  
        # List类型元素赋值时,每个元素都要以 "-" 开头,在这个"-"之后的所有配置,都是同一个元素的属性信息  
        # id表示当前路由的唯一标识,和其他配置没有对应关系,只是不能和后面的路由配置id相同  
        - id: gateway-beijing  
          # uri属性配置路由目标服务器名称，"beijing"指注册到nacos名称为"beijing"的微服务模块  
          # lb就是LoadBalance的缩写,表示支持负载均衡调用  
          uri: lb://beijing  
          # predicate:是断言的意思,断言指满足某些条件时,执行某些操作  
          # predicates又是一个List,所以它的赋值配置,也要以"-"开头  
          predicates:  
            # 下面是断言内容，Path是判断路径/bj/**表示判断路径是否以/bj/开头  
            # 当断言条件满足时,网关会将请求路由(分配)到上面uri设置的路径上  
            # ↓  P要大写!!!!  
            - Path=/bj/**
```

3. 测试
    - 先启动nacos
    - 再启动beijing
    - 最后启动gateway


## 网关 *多路由配置*

上面只配置了一个beijing的路由设置

下面我们修改yml文件也实现 *shanghai的路由设置*：
```yml
gateway:  
  # route是路由的意思,下面内容就是开始路由配置,因为网关项目可能有多个路由信息  
  # 所以网关路由配置是一个集合routes  
  routes:  
    # beijing配置略
    # shanghai项目元素  
    - id: gateway-shanghai  
      uri: lb://shanghai  
      predicates:  
        - Path=/sh/**
```


在保证nacos启动的情况下
beijing服务器如果启动无需重启
启动shanghai项目
最后重启网关
  
测试网关路由到两个模块的效果  
http://localhost:9000/bj/show 可以访问beijing服务器的资源
http://localhost:9000/sh/show 可以访问shanghai服务器的资源

以此类推，再有很多服务器时，我们都可以 **仅使用9000端口号** 来*将请求路由到正确的服务器*。
  
就*实现了gateway成为项目的 统一入口 的效果*。


## *动态路由*

网关项目的配置会随着微服务模块数量增多而变得复杂，维护的工作量也会越来越大。

所以我们希望gateway能够设计一套 *默认情况下 自动路由到每个模块* 的路由规则；
这样的话,不管当前项目有多少个路由目标，都不需要维护yml文件了。

这就是我们SpringGateway的动态路由功能。

**默认的路由规则**：
- 在 **网关端口号** 后，**先编写** *要路由到的 目标服务器* **注册到Nacos的名称**。
- 然后**再编写**要访问这个模块的*具体路径*。
- 例如：
    *localhost:9001/bj/show*  -> *localhost:9000/beijing/bj/show*

*yml配置文件*中开启即可：
```yml
gateway:  
  discovery:  
    locator:  
      # 开启动态路由设置  
      # 默认的路由规则：在网关端口号后，先编写要路由到的目标服务器注册到Nacos的名称  
      #                              然后再编写要访问这个模块的具体路径  
      # 例如：localhost:9001/bj/show  -> localhost:9000/beijing/bj/show
      enabled: true
```

按上面修改完配置之后 
我们可以重启gateway来测试动态路由路径是否生效  

动态路由生成规则为：在网关端口号后先写要路由到的目标服务器在nacos注册的名称，再编写具体路径




## *内置断言*

我们上面章节在网关配置中使用了 **predicates(断言)** 的配置。
断言的意思就是*判断某个条件是否满足*。

我们之前使用了 **Path断言**，*判断请求的路径* 是不是满足条件，例如是不是`Path=/sh/**`   `Path=/bj/**` 。 
如果路径满足这个条件,就路由到指定的服务器。
  
但是Path实际上只是SpringGateway提供的多种内置断言中的一种.
  
还有很多*其它断言*：（首字母都大写）
- ***所有断言配置*** 都是 "***与***" 的关系
- **After**：判断当前 *访问时间* **是否晚于** *配置时间*。
    - 如果当前时间 *早于* 配置的值，会发生 *404的错误*，只有晚于这个值才能正常访问。
- **Before**：判断当前 *访问时间* **是否早于** *配置时间*。
- **Between**：判断当前 *访问时间* **是否在** *两个配置时间* **之间**。
- Cookie  
- Header  
- Host  
- Method
- Path  
- **Query**：判断当前 **请求是否包含** 指定 *配置参数*。
- Remoteaddr


### **时间相关**：

*After,Before,Between*
判断当前时间在指定时间 *之前,之后或之间* 的操作  
  
如果条件满足可以执行路由操作,否则拒绝访问  
  
*表示时间的 格式 比较特殊*，先使用下面代码获得当前时间：
```java
ZonedDateTime.now()

// 运行程序输出，可获得当前时间，这个时间的格式可能是

2023-03-24T10:49:18.232+08:00[Asia/Shanghai]
```

下面在yml配置中添加新的断言配置： 
- 使用 *After* 设置必须在 *指定时间之后访问*
```yml  
routes:  
  - id: gateway-shanghai  
  uri: lb://shanghai  
  # 内置断言  
  predicates:  
    - Path=/sh/**   
    # After：时间断言，判断当前访问时间 是否晚于 配置时间  
    # 如果当前时间 早于 配置的值，会发生404的错误，只有晚于这个值才能正常访问。  
    - After=2023-03-24T10:55:00.232+08:00[Asia/Shanghai]
```  
  
- 使用 *Before* 设置必须在 *指定时间之前才能访问服务*  
    - 否则发生404错误拒绝访问    
```yml  
predicates:  
  - Before=2023-03-24T11:00:00.232+08:00[Asia/Shanghai]
```  
  
- 使用 *Between* 设置必须在 *指定时间之间访问*  
```yaml  
predicates:  
  - Between=2023-03-24T11:15:00.232+08:00[Asia/Shanghai],2023-03-24T11:25:00.232+08:00[Asia/Shanghai]
```



### **要求指定参数的请求**

**Query断言**，判断*是否包含指定的参数名称*，包含参数名称才能通过路由。

```yml  
predicates:  
  - Path=/sh/**  
  # Query断言判断请求中是否包含参数名称为username的参数,如果没有发生404  
  - Query=username  
```
重启gateway测试  
  
必须是 *包含username参数* 的请求才能访问到指定的页面  
例如： http://localhost:9000/sh/show?username=tom


## *内置过滤器*

了解即可

*Gateway* 还 *提供 内置过滤器*，
不要和我们学习的filter混淆  
  
内置过滤器允许我们在路由 **请求到** 目标资源的同时，**对这个请求**进行一些**加工或处理**。
  
常见过滤器也有一些
  
我们给大家*演示*一下 **AddRequestParameter过滤器**，
它的*作用*是在请求中 **添加参数和它对应的值**。
- *缺省值*：当参数原本就有该参数时，就不会再通过过滤器添加了
```yml
routes:  
  - id: gateway-shanghai    
    uri: lb://shanghai    
    filters:      
      # 如果路由成功，这个内置过滤器会在请求参数中添加名称为age，值为18的参数信息  
      - AddRequestParameter=age,18    
    predicates:      
      - Path=/sh/**      
      # Query断言判断请求中是否包含参数名称为username的参数，如果没有发生404  
      - Query=username
```

在 *shanghai* 的 **控制器方法** 中 添加代码 *接收 username和 age 的值*
```java
@GetMapping("/show")  
public String show(String username,Integer age){  
    System.out.println(ZonedDateTime.now());    
    return "这里是上海！姓名:" + username + ",年龄:" + age;  
}
```

重启shanghai和gateway进行测试  

http://localhost:9000/sh/show?username=jerry  
  
因为过滤器的存在，控制器可以获取网关过滤器添加的参数值：
![[gateway内置过滤器效果.jpg]]

其他内置过滤器和自定义过滤器的使用,同学们可以查阅相关文档自己了解

## 路由配置的 设计规则

路由规则解释：路由规则一定是在开发之前就设计好的，一般可以使用约定好的路径开头来实现的。

例如：
*gateway-demo项目*：
如果路径以 `/bj` 开头,就是要 *访问beijing项目*;
如果路径以 `/sh` 开头.就是要 *访问shanghai项目*;

*csmall项目*：
如果路径是 /base/business开头的,       就去找nacos-business服务器  
如果路径是 /base/cart开头的,             就去找nacos-cart服务器  
如果路径是 /base/order开头的,           就去找nacos-order服务器  
如果路径是 /base/stock开头的,            就去找nacos-stock服务器


## csmall项目网关

[[18. 使用getway网关]]



## Gateway 和 Spring MVC 依赖冲突问题和解决

之前网关的演示项目我们添加的网关依赖：
```xml
<!-- Spring Gateway 网关依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

当前csmall项目需要配置 *knife4j的路由配置*，*需要* 编写一个 **控制器**
所以我们*添加了SpringMVC的依赖*：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

以上两个依赖在同一个项目中时，*默认情况下启动会报错*！
  
**SpringMVC框架**依赖中 *自带* 一个 *Tomcat服务器*（IO，阻塞）；
而**SpringGateway框架**中 *自带* 一个 *Netty的服务器*（NIO，非阻塞）；

非阻塞：线程不等待，做请求、做相应不等待

在启动项目时，两个框架中包含的服务器 *都想占用相同端口*，因为争夺端口号的主动权而发生冲突，导致启动服务时报错。

**解决方法：**
想能够正常启动必须在 *Gateway模块* 的 *yml文件* **配置**
```yaml
spring:
  main:
    web-application-type: reactive
```
reactive：反应的  
  
添加这个配置之后，*Tomcat服务器* 会 **变成非阻塞的运行**。


