
*csmall-stock-webapi项目* 中测试RabbitMQ。
可以利用之前我们使用Quartz实现的每隔一段时间可以运行一个方法的功能实现。


## 添加配置

1. csmall-stock-webapi模块的 *pom.xml文件* 中 **添加依赖**：
```xml
<!-- Spring Boot整合RabbitMQ的依赖 -->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-amqp</artifactId>  
</dependency>
```

2. 配置 *yml文件*：
```yml
sping:
  # RabbiMQ消息队列的配置
  rabbitmq:
    # 端口号
    host: localhost
    port: 5672
    # 用户名密码
    username: guest
    password: guest
    # 设置虚拟host。单机模式下固定编写 "/" 即可
    virtual-host: /
  ```


## *交换机 / 路由Key / 队列的配置类*

RabbitMQ要求我们在 *Java代码级别* 设置 **交换机** / **路由Key** / **队列** 的 *关系*。
  
我们在quartz包下，创建config包，
包中创建*配置信息类* **RabbitMQConfig**：
```java
/**  
 * 当前类作用是定义 交换机 / 路由Key / 队列 的对象 和绑定关系  
 * 路由模式下，只有配置了这些信息，才能正常运行  
 */  
@Configuration  
public class RabbitMQConfig {  
  
    // 业务中，需要使用到的各种名称都要定义常量，防止拼写错误  
    public static final String STOCK_EX = "stock_ex";  
    public static final String STOCK_ROUT = "stock_rout";  
    public static final String STOCK_QUEUE = "stock_queue";  
  
    // 交换机和队列对象是 实例对象，保存到Spring容器  
  
    // 交换机对象  
    @Bean  
    public DirectExchange stockDirectExchange() {  
        return new DirectExchange(STOCK_EX);  
    }  
  
    // 队列对象  
    @Bean  
    public Queue stockQueue() {  
        return new Queue(STOCK_QUEUE);  
    }  
  
    // 路由Key是 表示关系 的对象，需要绑定相关的对象  
    @Bean  
    public Binding stockBinding() {  
        return BindingBuilder  
                .bind(stockQueue()).to(stockDirectExchange())  
                .with(STOCK_ROUT);  
    }  
  
}
```



## RabbitMQ发送消息

上面完成了RabbitMQ的 pom / yml 和 config 的配置。

使用Quartz进行定时发消息。

1. 在quartz包下新建一个rabbit包，包中创建 *RabbitMQJob* 类，实现 **RabbitMQ消息的发送**：
```java
/**  
 * 使用quartz实现定时 使用RabbitMQ发送消息  
 */  
@Slf4j  
public class RabbitMQJob implements Job {  
  
    /*  
        装配能够向RabbitMQ 发送消息的对象  
        这个对象也是在添加依赖后，项目启动时，自动保存到Spring容器的。  
     */    
    @Autowired  
    private RabbitTemplate rabbitTemplate;  
  
    /*  
	    声明成静态，每次才会加1  
		
	    因为当前类并没有保存在Spring容器中，  
	    到触发点时，JobDetail并不是从Spring容器中取出RabbitMQJob对象的，  
	    而是直接 新实例化一个RabbitMQJob对象。  
	    所以如果i不是静态变量，而是成员变量的话，每次实例化都会被重新赋值。  
	 */
    static int i = 1;  
  
    @Override  
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {  
        // 实例化Stock对象  
        Stock stock = new Stock();  
        stock.setId(i++);  
        stock.setCommodityCode("PC100");  
        stock.setReduceCount(1 + RandomUtils.nextInt(10));  
  
        // 下面开始发送消息，指定 交换机名称 和 路由key名称  
        rabbitTemplate.convertAndSend(  
                RabbitMQConfig.STOCK_EX,  
                RabbitMQConfig.STOCK_ROUT,  
                stock);  
        log.info("消息发送完成:{}", stock);  
    }  
}
```

2. 创建quartz配置类，*RabbitMQQuartzConfig类*：
```java
/**
 * RabbitMQ 的Quartz配置类
 */
@Configuration
public class RabbitMQQuartzConfig {
  
    @Bean  
    public JobDetail sendMessage() {  
        return JobBuilder.newJob(RabbitMQJob.class)  
                .withIdentity("sendMessage")  
                .storeDurably()  
                .build();  
    }  
  
    @Bean  
    public Trigger sendMessageTrigger() {  
        CronScheduleBuilder cron = CronScheduleBuilder.cronSchedule("0/10 * * * * ?");  
  
        return TriggerBuilder.newTrigger()  
                .withIdentity("sendMessageTrigger")  
                .forJob(sendMessage())  
                .withSchedule(cron)  
                .build();  
    }
}
```

启动服务会每隔10秒运行一次发送消息的操作

启动服务，观察是否每隔10秒发送一条消息

启动 Nacos / RabbitMQ / Seata

启动stock-webapi

根据Cron表达式，消息会在 0/10/20/30/40/50秒数 时运行




## 接收RabbitMQ中的消息

quartz.rabbit包下再创建一个新的类 **用于接收信息**。
  
*RabbitMQConsumer*代码如下：
```java
/**  
 * Spring连接RabbitMQ也是通过我们添加的依赖来实现的  
 * 所以要接收消息，当前类必须在Spring容器中  
 */  
@Slf4j  
@Component  
// 和kafka不同，RabbitMQ接收消息的监听配置要写在类上  
@RabbitListener(queues = RabbitMQConfig.STOCK_QUEUE)  
public class RabbitMQConsumer {  
  
    /*  
        类上添加了监听的注解，但是不能指定收到消息后运行的方法。  
        所以我们要编写一个方法，并在方法前添加@RabbitHandler注解，  
        标记该方法是接收处理消息的方法，一个类只能有一个标记为@RabbitHandler的方法。  
        方法的参数直接写发送的消息的类型即可  
     */    
    @RabbitHandler  
    public void received(Stock stock) {  
        // stock对象就是发送过来的消息，直接使用即可，我们这里就是输出  
        log.info("接收到的消息：{}", stock);  
    }  
      
}
```

其他项目不动，继续保持运行  
  
重启stock-webapi模块  
  
观察消息的接收。