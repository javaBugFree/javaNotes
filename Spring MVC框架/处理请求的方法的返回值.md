
在Spring MVC 框架中，处理请求的方法的返回值，默认表示 **视图组件的名称**，即 *处理完请求后，由哪个视图来负责显示*，这 **不是** 前后端分离的做法。

目前，主流的开发模式是前后端分离的，更加 *适用于 多种不同 客户端软件的项目中*。
在**前后端分离**的做法中，*服务器端*是 **不处理视图** 的，而是将处理请求后得到的**数据** *响应到客户端*，由 *客户端决定* 如何处理此数据。  
  
在处理请求的 **方法上**，使用`@ResponseBody`注解，可以使得*此方法*是**响应正文**的，即：方法的返回值会直接响应到客户端去！  
还可以将`@ResponseBody`注解添加在 **控制器类上**，则当前控制器类中*所有处理请求的方法*都是**响应正文**的。

添加了`@Controller`注解的类会被作为控制器类，也可以改为使用`@RestController`，
其*源代码*如下：
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
   @AliasFor(annotation = Controller.class)   String value() default "";
}  
```  
  
所以，在类上添加 `@RestController`，可以将此类*标记为控制器类*，**并且**，表示此类中所有*处理请求的方法 都是响应正文* 的！

<hr>

## 关于响应结果

目前，当*成功*地添加相册后，服务器端响应的结果是：
`添加相册成功！`
如果相册名称已经*被占用*，服务器端响应的结果是：
`添加相册失败，相册名称已经被占用！`
以上的响应结果是**不合适的**，因为客户端不便于通过以上结果判断本次请求是否被成功的处理了，或是处理结果是否失败。
<br>
如果服务端改为使用数字作为响应结果，与客户端协商不同的的数字所表示的意义，例如使用`1`表示成功，使用`0`表示失败，这种做法更利于客户端判断操作成功与否，但是，却需要客户端自行组织后续的文本，以在界面上显示相关提示，而客户端自行组织文本也是不合适的，特别是操作失败时，仍应该是 **谁抛出，谁描述** ，客户端不一定能够准确的、统一的组织这些文本，所以，仍应该是由服务端响应操作失败的描述文本。
<br>
所以，服务器端响应的结果中应该 *既包含* **数字** 这类标志着成功与失败的数据，*还应该包含* **描述文本**。
但*一种返回值类型 只能 返回一种数据*，所以，响应的这多个部分我们使用 **JSON** 格式组织起来，则客户端收到后，可以从中取出任何所需的部分的数据：
```json
{
	"xx": "1",
	"xx": "添加相册成功"
}
```

<hr>

## 响应JSON格式的数据

在Spring MVC框架中，***当需要向客户端响应JSON格式的数据时***，需要：
1. 处理请求的 **方法** 必须是 **响应正文** 的：
    - 在控制器类上添加 `@RestController` / 在方法上添加`@ResponseBody` / 在控制器类上添加 `@ResponseBody`
	<br>
2. 开启**注解驱动**：
    - 如果是使用 **XML配置** 的Spring MVC项目，需要在XML配置文件中添加`<annotation-driven/>。`
    - 如果是使用 **注解配置** 的Spring MVC项目，需要在配置类上添加 `@EnableWebMvc`。
    - 如果是 **Spring Boot项目**，则不需要添加任何配置。
    <br>
3. 添加 `jackson-databind` **依赖项**：
    - 在 `spring-boot-start-web` 依赖项中包含此依赖项：
        ![[jackson-databind 依赖项.png]]
    <br>
4. 使用 **自定义的数据类型** 作为处理请求的方法的*返回值类型*：
    1. 在项目的根包下创建`web 包`，在该包内创建Web相关的类。
       
    2. 创建 `JsonResult 类`（*类名是完全自定义的*），并*在类中声明* 需要 **响应到客户端的 数据属性**，也可以理解为声明期望响应的*JSON数据中的属性*：
        ```java
        @Data
        @NoArgsConstructor  // 生成无参构造方法  
		@AllArgsConstructor  // 生成全参构造方法
        public class JsonResult implements Serializable {
            private ServiceCode state;
            private String message;
            
            /**  
			 * 成功时 给客户端的响应  
			 *  
			 * @return JsonResult对象  
			 */  
			public static JsonResult success() {  
			    JsonResult jsonResult = new JsonResult();  
				jsonResult.setState(ServiceCode.OK.getValue());
				
				return jsonResult;
			}  
			  
			/**
			 * 失败时 给客户端的响应
			 *
			 * @param state   错误码 ServiceCode类型
			 * @param message 错误信息
			 * @return JsonResult对象
			 */
			public static JsonResult fail(ServiceCode state, String message) {      //                        ↑↑↑ 由原本的Integer改为ServiceCode
			    // 则方法的调用者只能传入`ServiceCode`中的某个枚举值，不可以传入任意值！
			    JsonResult jsonResult = new JsonResult();
				jsonResult.setState(state.getValue());
				jsonResult.setMessage(message);
				
				return jsonResult;
			}
        }
        ```
        - 关于 `JsonResult` 中的 `String message` 属性，其 **作用是** 避免客户端在描述 *失败* 时组织的文本不统一，或不准确。在 *成功* 时，其实并不需要此属性！
            - 因为在操作成功时，由客户端自行组织描述文本，通常不会出现歧义，甚至，在许多业务中，操作成功后，只需要让客户端的软件界面发生变化即可，并不需要提示一段信息！
        - 同时，为了进一步更好的管理 **状态码**`state`*属性*，应该将这些状态码定义在专门的类型中. 
            - 例如，在项目的根包下创建 `web.ServiceCode` **枚举类**，用于管理各个可能使用到的业务状态码：
                ```java
                /**
				 * 枚举类
				 * 把所有 有可能的值 都列举出来
				 * 枚举出来 给客户端响应时的 状态码
				 */
				public enum ServiceCode {  
				    // 理解为 OK 和 ERR 等每一个枚举值，都是ServiceCode的对象
				    // 赋值时就是调用构造方法 
				    OK(20000),
				    ERR_NOT_FOUND(40400),  
				    ERR_CONFLICT(40900);
				  
				    // value 表示每一个枚举对象中的value属性
				    private Integer value;
				  
				    // 枚举的构造方法 权限修饰符 固定为 私有
				    ServiceCode(Integer value) {
				        this.value = value;
				    }
				  
				    // 通过此方法让外界获取枚举对象的value值
				    public Integer getValue(){
				        return value;
				    }
				}
				```
    
    3. 然后，将 *处理请求的方法* 的 **返回值类型** 改为 `JsonResult`，并调整内部实现，处理完请求后返回此类型的对象：
        ```java
        // http://localhost:8080/album/add-new
		@PostMapping("/add-new")    // 限制只能发出Post请求
		@ApiOperation("添加相册")   // 配置业务名称
		@ApiOperationSupport(order = 100)     // 自定义业务顺序
		public JsonResult add(AlbumAddNewDTO albumAddNewDTO) {
		    try {
		        albumService.addNew(albumAddNewDTO);
		        // 调用 JsonResult类中的 success成功方法
		        return JsonResult.success(ServiceCode.OK);
		    } catch (ServiceException e) {
			    // 调用 JsonResult类中的 
		        return JsonResult.fail(ServiceCode.ERR, e.getMessage());
		    }
		}
		```
		至此，既保证了响应的业务状态码（`JsonResult`中的`state`）是数值类型的，又保证了传入的值只能是限定的某个值（只能是`ServiceCode`中列举的某个值）。
	
	4. 完成后，*重启项目*，再次通过*API文档调试*访问，
	    - 当添加相册成功时，响应结果为：
		    ```json
		    {
			  "state": 20000,
			  "message": "添加相册成功！"
			}
			```
        - 当相册名称已经被占用，导致添加失败时，响应结果为：
            ```json
            {
			  "state": 40900,
			  "message": "添加相册失败，相册名称已经被占用！"
			}
			```

<hr>

## 枚举的状态码

各枚举值的状态码虽然是自定义的，但强烈推荐是有一定规律的！

如果没有合适的规律，可以参考HTTP状态，
例如，在HTTP状态码中：
- `200` 表示：*成功* 的意义。
- `404` 表示：*不存在* 的意义。
- `409` 表示：*冲突* 的意义。
则可以将枚举值改为：
```java
public enum ServiceCode {
	
    OK(20000),
    ERR_NOT_FOUND(40400),
    ERR_CONFLICT(40900);
    
    // 暂不关心此类型中的其它代码
}
```

<br>

关于 *异常的描述文本*，应该是 **谁抛出，谁描述**，
而 *业务状态码*（**JsonResult** 中的 `state` 或 `ServiceCode` 的值），也应该是 **谁抛出，谁定值**，而不应该是有捕获异常的一方来决定业务状态码。而现有的代码是：
```java
@PostMapping("/add-new")
public JsonResult addNew(AlbumAddNewDTO albumAddNewDTO) {
    try {
    albumService.addNew(albumAddNewDTO);
    return JsonResult.ok();
    } catch (ServiceException e) {
        //                     ↓↓↓↓↓↓ 捕获异常时确定业务状态码，是“不合适”的
        return JsonResult.fail(ServiceCode.ERR_CONFLICT, e.getMessage());
    }
}  
```
是在 捕获异常时确定业务代码，是不合适的！
<br>

1. 目前，抛出的异常对象中*只包含*“描述文本”，如果还要包含“业务状态码”，则应该调整异常类型的源代码：
```java
public class ServiceException extends RuntimeException {
	
    private ServiceCode serviceCode;
	
    // 关键需要此构造方法
    // message 可以被 该异常的对象 使用 .getMessage() 获取到
    public ServiceException(ServiceCode serviceCode, String message) {
        super(message);
        this.serviceCode = serviceCode;
    }
	
    // serviceCode 可以通过此方法被获取搭配
    public ServiceCode getServiceCode() {
        return serviceCode;
    }
}
```
以上调整的思路：  
- 在异常类型中 *声明`ServiceCode`属性*，表示此类型的异常中*将包含* **业务状态码**。
- *调整现 仅有的 构造方法*，添加 `ServiceCode`类型 的参数，表示**强制要求传入此值**，否则不允许创建此类型的异常对象
- 为了*便于后续获取*到此类型的异常对象中通过构造方法传入的`ServiceCode`值，还需要添加**Getter方法**
<br>

2. 完成后，当需要 **抛出异常时**，必须通过以上的*唯一的构造方法*，例如在`AlbumServiceImpl`的`addNew()`方法中调整：
```java
if (countByName > 0) {
    // 如果已经被占用，抛出异常，会直接结束该方法
    String message = "添加相册失败，相册名称已经被占用";
    log.warn(message);
    // 抛出异常，传入 状态码 和 描述
    // 【调整】在构造方法中封装 serviceCode 和 message
    throw new ServiceException(ServiceCode.ERR_CONFLICT, message);
}
```
<br>

3. 后续，当 **处理异常** 时，可以调用捕获到的异常对象的`getServiceCode()`方法得到业务状态码，例如在`AlbumController`中处理“添加相册”的请求时：
```java
@PostMapping("/add-new")
public JsonResult addNew(AlbumAddNewDTO albumAddNewDTO) {
    try {
    albumService.addNew(albumAddNewDTO);
    return JsonResult.ok();
    } catch (ServiceException e) {
	    //                     ↓↓↓↓↓↓↓ 从异常对象中取出 业务状态码
        return JsonResult.fail(e.getServiceCode(), e.getMessage());
    }
}
```

为了进一步简化 **JsonResult** 的调用，可以在 **JsonResult** 中重载 `fail()` 方法，直接*传参*一个**异常对象**。
```java
public static JsonResult fail(ServiceException e) {
    // JsonResult jsonResult = new JsonResult();
    // jsonResult.setState(e.getServiceCode().getValue());
    // jsonResult.setMessage(e.getMessage());
    // return jsonResult;
    
    return fail(e.getServiceCode(), e.getMessage());
}
```

**提示：** 原本的 `public static JsonResult fail(ServiceCode state, String message) {}` 仍需要保留下来，后续出现其他异常时需要使用到。

当添加了以上新的 `fail()` 方法后，在 **AlbumController** 中 *捕获并处理异常的代码* 可以简化：：
```java
@PostMapping("/add-new")    // 限制只能发出Post请求
public JsonResult add(AlbumAddNewDTO albumAddNewDTO) {
    try {
        albumService.addNew(albumAddNewDTO);
        return JsonResult.success();    // 不需要响应成功时的描述
    } catch (ServiceException e) {
        //                     ↓ 只需要传入异常参数即可  
        return JsonResult.fail(e);
    }
}
```


<hr>


## 响应结果中的 *null值*

目前，服务器端处理完请求后，会向客户端响应JSON格式的结果，但是，某些情况下，会有一些属性的值为`null`，例如，当*成功的添加相册*后，响应的结果是：  
```json
{
  "state": 20000,
  "message": null
}
```  
以上 **`message`属性** 是 *没有必要响应* 的，因为此属性的作用是“失败”时的提示文本，当操作成功时，此属性的值一定是`null`值，将此属性响应到客户端去是没有任何意义的！  
<br>
**解决方法：**
- 可以在响应结果 **对应的属性上** 配置`@JsonInclude`注解，例如：  
```java  
@Data
public class JsonResult implements Serializable {
	
    private Integer state;
    // @JsonInclude用于配置“此属性什么时候会包含在JSON结果中”
    // NON_NULL 表示 不为null的时候
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String message;
}  
```  

- 也可以将此注解添加在 **类上**，则 **类中** *每个属性都是此配置*：  
```java  
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
// 在类上配置，每个属性都遵循此配置
public class JsonResult implements Serializable {
	
    private Integer state;
    private String message;
}  
```  
  
- 或者，还可以在 **配置文件中**，通过`spring.jackson.default-property-inclusion`属性进行作用于*整个项目的全局配置*！例如，在`application.yml`中添加：  
```yaml  
# Spring相关配置
spring:
  # jackson框架的相关配置
  jackson:    # 服务器端响应JSON结果时，JSON结果中默认包含哪些属性
    default-property-inclusion: non_null # 表示 所有的属性都是 不为null时显示
```
  
**提示：** 在*配置文件中*、在*类上*、在*类的属性上*，*都可以配置* “是否包含在JSON结果中”，*通常* 只需要在 主配置文件 中配置即可，
但是，如果在 **多处都配置了**，以 **作用域** *更小的为准*，例如，在类上和在类的属性上都配置了，但配置值不同，则以在类的属性上的配置为准！

