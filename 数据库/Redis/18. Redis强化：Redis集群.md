
Redis **最小状态** 是 *一台服务器*，
这个服务器的运行状态，*直接决定* Redis是否可用。

如果它离线了，整个项目就会无Redis可用，系统会面临崩溃。
  
为了防止这种情况的发生，我们可以准备一台 **备用机**。


## **主从复制**：

![[Redis主从复制.png]]
也就是**主**机（master）工作时，安排一台**备**用机（slave）**实时同步数据**，万一*主机宕机*，我们可以*切换到备机运行*。
  
*缺点*：这样的方案，slave节点 *没有任何实质作用*，只要master不宕机它就和没有一样，没有体现价值。

**读写分离**：
![[Redis读写分离.png]]

这样 **slave** 在 *master正常工作时* **也能分担** Master的 *工作* 了。
  
但是如果master宕机，实际上 **主备机的切换**，实际上 **还是需要人工介入** 的，这*还是需要时间* 的。
  
那么 *如果想实现* **发生故障时 自动切换**，一定是有*配置好的固定策略*的。


## **哨兵模式**：故障自动切换

![[Redis哨兵机制.png]]

哨兵节点 **每隔固定时间** *向所有节点发送请求*，
  
如果 **正常响应**，认为该节点 *正常*  
如果 **没有响应**，认为该节点 *出现问题*，哨兵能**自动切换主备机**。

如果 **主机master下线**，*自动切换到备机运行*：
![[Redis哨兵机制 自动切换主备机.png]]

但是如果哨兵判断节点状态时发生了 **误判**，那么就会 *错误将master下线*，**降低整体运行性能**。
  
所以*要减少哨兵误判的可能性*：


### *哨兵集群*

![[Redis哨兵集群.png]]

我们可以将哨兵节点做成集群，由 **多个哨兵投票决定** *是否下线某一个节点*。
  
哨兵集群中，**每个哨兵节点** 都会*定时向master和slave发送 ping请求*。
  
如果 *ping请求* 有2个（**集群的半数节点**）以上的哨兵节点 *没有收到正常响应*，会*认为该节点下线*。

当业务不断扩展，并发不断增高时。


### *分片集群*

只有 **一个节点** 支持 **写操作无法满足整体性能要求** 时，*系统性能就会到达瓶颈*。
  
这时我们就要 *部署* **多个支持写操作的节点**，*进行分片*，来 **提高程序整体性能**。
  
**分片** 就是 *每个节点负责不同的区域*。
  
例如：Redis有，0~16383号槽，

MasterA：负责0~5000
MasterB：负责5001~10000
MasterC：负责10001~16383

*一个key* 根据 *CRC16算法* 只能 *得到固定的结果*，一定 **在指定的服务器上找到数据**。
![[Redis哨兵机制 分片集群.png]]

有了这个集群结构，我们就能更加稳定和更加高效的处理业务请求了。

哨兵集群 会对 *分片集群中 每一对主备机* 都进行监视，来判断是否切换服务器。

**为了节省哨兵服务器的成本**，*有些公司* **在Redis集群中直接添加哨兵功能**，即 *master / slave节点* **完成数据读写任务的同时**，**也都互相检测** *它们和其他的服务器的* **健康状态**。
- 例如，哨兵都装在master或都装在slave中，每一个服务器中都有哨兵的功能。
    - 即：每个服务器 既负责Redis普通的功能，也去向其他服务器发ping进行验证。
    - 或者说，这个服务器，既装备Redis，也装备哨兵程序。
- 如果其中某一个master或slave出问题了，其他的master或slave就会对其进行投票。

> 有额外精力的同学，可以自己查询 **Redis分布式锁 的解决方案(redission等)**。