
ES是一个 *数据库性质* 的软件。
  
可以执行增删改查操作，只是它操作数据 **不使用sql**，*数据的结构* 和 *关系型数据库* **也不同**。

我们先了解一下 *ES保存数据的结构*：
![[ES保存数据的结构.png]]

* ES启动后，ES服务可以创建多个 **index**(*索引*)，index可以*理解为* **数据库中表** 的概念。
* 一个index可以创建多个 **保存数据** 的 **document**(*文档*)，一个document*理解为* **数据库中的一行数据**。
* 一个document中*可以保存* **多个属性和属性值**，对应 **数据库中的字段(列) 和 字段值**。
  
项目csmall-finish项目中，note文件夹下共享了ES文档，命令都在里面，可以测试  
所有的代码都在 "ES文档" 中，笔记略。

[[0. ES文档]]

下面我们要学习使用java代码来操作ES

# Spring Boot 操作 Elasticsearch

## Spring Data简介

原生状态下，我们使用*JDBC连接数据库*，因为*代码过于繁琐*，所以改为使用*Mybatis框架*。
在ES的原生状态下，我们java代码需要使用*socket访问ES*，但是也是*过于繁琐*，我们可以使用*SpringData框架*简化。
  
**Spring Data**是Spring提供的一套 *连接各种第三方数据源* 的 **框架集**。

我们需要使用的是其中 *连接ES* 的 **Spring Data Elasticseatrch**。
  
官方网站:https://spring.io/projects/spring-data
![[SpringData简介.png]]

官网中列出了SpringData *支持连接操作* 的 *数据源列表*。


## 开始操作

下面我们就按照SpringDataElasticsearch的步骤对ES进行操作：

1. 修改search模块的 *pom.xml文件*
```xml
<?xml version="1.0" encoding="UTF-8"?>  
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <modelVersion>4.0.0</modelVersion>  
    <parent>  
        <groupId>cn.tedu</groupId>  
        <artifactId>csmall</artifactId>  
        <version>0.0.1-SNAPSHOT</version>  
        <relativePath/> <!-- lookup parent from repository -->  
    </parent>  
    <groupId>com.example</groupId>  
    <artifactId>search</artifactId>  
    <version>0.0.1-SNAPSHOT</version>  
    <name>search</name>  
    <description>search</description>  
  
    <dependencies>  
        <dependency>  
            <groupId>org.springframework.boot</groupId>  
            <artifactId>spring-boot-starter</artifactId>  
        </dependency>  
  
        <dependency>  
            <groupId>org.springframework.boot</groupId>  
            <artifactId>spring-boot-starter-test</artifactId>  
            <scope>test</scope>  
        </dependency>  
          
        <!-- Spring Data Elasticsearch 整合SpringBoot依赖 -->  
        <dependency>  
            <groupId>org.springframework.boot</groupId>  
            <artifactId>spring-boot-starter-data-elasticsearch</artifactId>  
        </dependency>  
    </dependencies>  
  
</project>
```


2. *application.properties*添加配置
```properties
# 配置ES的ip和端口号  
spring.elasticsearch.rest.uris=http://localhost:9200  
# 设置日志门槛  
logging.level.com.example.search=debug  
#Spring Data Elasticsearch 框架内部也有一个能输出日志信息的类，为它设置门槛  
logging.level.org.elasticsearch.client.RestClient=debug
```


### 3. 创建 *和 ES关联*  的 **实体类**

和数据库一样，
我们操作ES时也需要一个类似实体类的数据类，作为操作ES的数据载体。

1. search项目创建 *entity包*  

2. 在包中创建 *Item(商品)类*
    - `@Accessors(chain = true)`：添加在*类上*，声明该类支持链式set赋值
    
    - `@Document(indexName = "items")`：
        - 添加在*类上*
        - SpringDataElasticsearch框架标记的一个 **对应** *ES中索引* 的实体类注解。
        - `indexName`：指定ES中 *索引的名称*，运行时，如果索引*不存在*，SpringData会*自动创建*这个索引。
    
    - `@Id`：添加在*属性上*，SpringData 通过 *@Id* **标记**当前实体类 **主键**。
      
    - `@Field`：表示 **对应ES** 中的 **一个字段**。
        - `@Field(type = FieldType.Text, analyzer = "ik_max_word", searchAnalyzer = "ik_max_word")`：表示该字段 **需要分词**，且按照如上词库进行分词。
        - `@Field(type = FieldType.Keyword)`：声明该字段为 *关键字*，表示 **不用分词 的 字符串**。
        - `@Field(type = FieldType.Date)`：表示 **Double类型** 的 **数字**。
        - `@Field(type = FieldType.Keyword, index = false)`：设置当前字段**不创建索引**，节省一定空间。
            - 但是当前字段还是会保存到ES中的。
```java
/**  
 * 商品类  
 */  
@Data  
@AllArgsConstructor // 生成全参构造  
@NoArgsConstructor  // 生成无参构造  
@Accessors(chain = true)    // 声明该类支持链式set赋值
/*  
    @Document是SpringDataElasticsearch框架标记的一个对应ES中索引的实体类注解  
    indexName指定ES中索引的名称，运行时，如果索引不存在，SpringData会自动创建这个索引
*/
@Document(indexName = "items")
public class Item implements Serializable {  
  
    // SpringData 通过@Id标记当前实体类主键  
    @Id
    private Long id;  
  
    // @Filed：表示对应ES中的一个字段  
    @Field(type = FieldType.Text, analyzer = "ik_max_word", searchAnalyzer = "ik_max_word")
    private String title;  
  
    // FiledType.Keyword：关键字，表示不用分词的字符串。  
    @Field(type = FieldType.Keyword)
    private String category;  
  
    @Field(type = FieldType.Keyword)  
    private String brand;  
  
    // FiledType.Double：表示Double类型的 数字  
    @Field(type = FieldType.Date)  
    private Double price;  
  
    // imgPath是图片路径的属性，不会成为搜索条件，所以这个字段不需要创建索引  
    /*  
        index = false：设置当前字段不创建索引，节省一定空间  
        但是当前imgPath字段还是会保存到ES中的  
     */    
    @Field(type = FieldType.Keyword, index = false)
    private String imgPath;  
  
}
```


### 4. 创建操作ES的 **持久层**

我们使用SpringData连接ES，
  
需要知道SpringData框架对持久层的命名规则：
持久层规范名称为 **repository(仓库)**。

1. 创建这个包，包中创建接口 *ItemRepository*
    - ItemRepository接口 **继承** *ElasticsearchRepository父接口*，是SpringData提供的
    - ElasticsearchRepository接口 **泛型** `<要操作的实体类, 这个实体类的主键类型>`。
    - 继承之后，当前接口能够 **直接调用** 父接口中声明操作ES的方法，*包括基本增删改查*。
```java
/**  
 * 持久层  
 */  
// @Repository是Spring家族框架对持久层的命名规范  
@Repository  
public interface ItemRepository extends ElasticsearchRepository<Item, Long> {  
  
    // ItemRepository接口继承ElasticsearchRepository父接口，是SpringData提供的  
  
    // ElasticsearchRepository接口泛型<要操作的实体类, 这个实体类的主键类型>  
  
    // 继承之后，当前接口能够直接调用父接口中声明操作ES的方法，包括基本增删改查  
  
}
```


### 5. 测试ES

如果没有测试包,创建test测试包
如果没有测试类,创建测试类

编写测试：
```java
@SpringBootTest  
class SearchApplicationTests {  
  
    @Autowired  
    private ItemRepository itemRepository;  
  
    @Test  
    void contextLoads() {  
    }  
  
    // 执行单增  
    @Test  
    void addOne() {  
        // 实例化Item对象  
        Item item = new Item()  
                .setId(1L)  
                .setTitle("罗技激光无线游戏鼠标")  
                .setCategory("鼠标")  
                .setBrand("罗技")  
                .setPrice(168.0)  
                .setImgPath("/1.jpg");  
  
        // 利用SpringDataElasticsearch框架提供的新增方法，完成新增到ES  
        itemRepository.save(item);  
  
        System.out.println("ok");  
    }  
  
    // 执行单插  
    @Test  
    void getOne() {  
        // Optional：可以理解为只能装一个元素的list  
        Optional<Item> optional = itemRepository.findById(1L);  
        // 从Optional获取查询出的元素  
        Item item = optional.get();  
        System.out.println(item);  
    }  
  
    // 批量增  
    @Test  
    void addList() {  
        // 实例化一个List 把要保存到ES中的数据添加到这个集合  
        List<Item> list = new ArrayList<>();  
  
        list.add(new Item(2L, "罗技激光有线办公鼠标", "鼠标",  
                "罗技", 98.0, "/2.jpg"));  
        list.add(new Item(3L, "雷蛇机械无线游戏键盘", "键盘",  
                "雷蛇", 268.0, "/3.jpg"));  
        list.add(new Item(4L, "微软有线静音办公鼠标", "鼠标",  
                "微软", 166.0, "/4.jpg"));  
        list.add(new Item(5L, "罗技机械有线背光键盘", "键盘",  
                "罗技", 222.0, "/5.jpg"));  
  
        // 执行批量新增的操作  
        itemRepository.saveAll(list);  
        System.out.println("ok");  
    }  
  
    // 全查  
    @Test  
    void getAll() {  
        // SpringData提供的全查所有items索引中数据的方法  
        Iterable<Item> items = itemRepository.findAll();  
  
        // 新循环遍历  
        for (Item item : items) {  
            System.out.println(item);  
        }  
  
        // forEach遍历  
        items.forEach(item -> System.out.println(item));  
  
        // 迭代器遍历  
        Iterator<Item> iterator = items.iterator();  
        while (iterator.hasNext()) {  
            Item next = iterator.next();  
            System.out.println(next);  
        }  
  
    }  
  
}
```

