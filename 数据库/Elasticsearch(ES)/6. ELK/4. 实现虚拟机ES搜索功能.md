
之前我们已经 *修改了yml文件*，*将搜索的目标更换为虚拟机中的ES*。
  
在虚拟机的连接环境中，我们使用 **SpuEntity** 来 **实现ES的连接**。
  
我们可以看到SpuEntity *类中没有任何 编写分词的属性*，
  
原因是 *为了更高效的实现分词*，logstash **将所有需要分词的列** *拼接组合* 成了一个新列**search_text**

![[Logstash分词合并.png]]
  
当需要查询时只需要查询search_text字段即可。


## 添加新的持久层  
  
在search-webapi模块中的repository包下，创建新的持久层接口 *SpuEntityRepository*：
- logstash将所有商品spu需要进行分词的字段，拼接成了一个新的字段 **search_text**        
- 又因为SpuEntity *没有在类中声明这个字段*，所以*只能编写查询语句完成查询*
```java
/**  
 * 实现虚拟机ES搜索功能  
 */  
@Repository  
public interface SpuEntityRepository extends ElasticsearchRepository<SpuEntity, Long> {  
  
    /*  
        根据用户输入的关键字，搜索ES中匹配的商品  
        logstash将所有商品spu需要进行分词的字段，拼接成了一个新的字段 search_text        
        又因为SpuEntity没有在类中声明这个字段，所以只能编写查询语句完成查询  
     */    
    @Query("{\"match\":{\"search_text\":{\"query\":\"?0\"}}}")  
    Page<SpuEntity> querySearchByText(String keyword, Pageable pageable);  
}
```


## 实现业务逻辑层代码  
  
原来的业务逻辑层实现类，*要废弃*，可以删除；
如果不想删除也要 *把之前代码注释*，还有 *必须删除/注释 @Service注解*。
  
1. 原有 *SearchServiceImpl* 修改为：
```java
// @Slf4j  
// @Service  
@Deprecated
public class SearchServiceImpl { // implements ISearchService {
	// 其中所有代码均可注释    
}
```

2. 上面的类处理完毕后，要 *修改 业务逻辑层接口* **返回值的实体类型为SpuEntity**：
```java
public interface ISearchService {  
  
    // ES分页查询spu的方法  
    // JsonPage<SpuForElastic> search(String keyword, Integer page, Integer pageSize);  
    JsonPage<SpuEntity> search(String keyword, Integer page, Integer pageSize);  
  
    // 向ES中加载数据的方法  
    void loadSpuByPage();  
}
```

3. 新建 *SearchRemoteServiceImpl* **实现ISearchService接口**，代码如下：
```java
/**  
 * 实现虚拟机 ES搜索功能  
 */  
@Slf4j  
@Service  
public class SearchRemoteServiceImpl implements ISearchService {  
  
    // 装配新创建的ES持久层对象  
    @Autowired  
    private SpuEntityRepository spuEntityRepository;  
  
    @Override  
    public JsonPage<SpuEntity> search(String keyword, Integer page, Integer pageSize) {  
  
        // 调用根据用户输入关键字执行分页查询ES的方法  
        Page<SpuEntity> spus = spuEntityRepository.querySearchByText(keyword, PageRequest.of(page - 1, pageSize));  
  
        // 将Page类型转换为JsonPage类型  
        JsonPage<SpuEntity> jsonPage = JsonPage.restPage(spus, page, pageSize);  
  
        return jsonPage;  
    }  
  
    @Override  
    public void loadSpuByPage() {  
    }  
}
```


## 修改控制层代码

修改 *SearchController* 中的代码：
```java
@Slf4j  
@RestController  
@RequestMapping("/search")  
@Api(tags = "搜索模块")  
public class SearchController {  
  
    @Autowired  
    private ISearchService searchService;  
  
    // 当前方法注解@GetMapping后面什么都不写  
    // 表示当前方法使用类上的路径做url  
    // localhost:10008/search    @GetMapping  
    @ApiOperation("根据用户输入的关键字分页查询商品信息")  
    @ApiImplicitParams({  
            @ApiImplicitParam(name = "keyword", value = "搜索关键字", example = "手机"),  
            @ApiImplicitParam(name = "page", value = "页码", example = "1"),  
            @ApiImplicitParam(name = "pageSize", value = "每页条数", example = "2")  
    })  
    //                        ↓↓↓↓↓↓↓↓↓↓↓ 修改的代码
    public JsonResult<JsonPage<SpuEntity>> searchByKeyword(String keyword, Integer page, Integer pageSize) {  
	    //      ↓↓↓↓↓↓↓↓↓↓↓ 修改的代码
        JsonPage<SpuEntity> jsonPage = searchService.search(keyword, page, pageSize);  
  
        return JsonResult.ok(jsonPage);  
    }  
}
```


## 测试

保证 **虚拟机启动**；
启动 passport / search。
  
先进行jwt登录的复制，复制到search模块的全局参数中。

可以搜索 "手机" 查询效果。
  
我们可以 *修改数据库中的数据*，*ES会自动跟随数据库变化*，因为Logstash的功能。
  
**如果不能** 查询出数据库中正确的对应的信息，
需要在 *数据库工具软件(HeidiSQL)* 中运行下面代码：
```sql
UPDATE pms_spu
SET gmt_modified=NOW()
WHERE 1=1     // 防止报错
```

以 **激活** *logstash对spu表* 的 **监听**，**并向ES中保存数据**。
  
这个操作可能有些延迟，稍等即可。
  
再次查询，就有能够正确搜索信息了！