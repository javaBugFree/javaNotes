
**接口就是一种规则。**

## 为什么要有接口

在继承体系中，可能一个方法*并不是所有*的子类都适合，但也*有一部分*子类*适合*，
而在每个适合的子类中都添加一个这个方法，不利于方法的统一规范性，所以接口就出现了。

在接口中可以 *定义一些方法作为规则*，适合这些规则的类可以有选择性的去继承，实现代码的规范性。

![[为什么要有接口.png]]


## 接口的应用

在之前的学习中，如果给一个方法传递一个同样可以完成目标的对象，但由于不是参数指定的对象，就会报错。
例如：
![[接口的应用1.png]]

而使用接口类型 作为参数，只要传递的对象按照接口规定的规则，就可以进行传递。
例如：
![[接口的应用2.png]]


## 接口和抽象类的异同

- 接口是接口，抽象类是类；
- 接口是*规则*，抽象是*共性*；
    - 接口就是一种规则，是对行为的抽象
- 抽象是所有子类的共性，接口可以是部分子类的共性；
- 接口是对行为的规范。
- *接口* 中的方法 **都需要重写**，而 *抽象类* 中的 **只需要重写抽象方法**。

> [!NOTE] 区别
> 1. 接口 *不能* 实现普通方法，抽象类 *可以实现* 具体的方法，也可以不实现。
> 2. 接口 *只能* 定义静态变量，抽象类 *可以定义* 非静态变量。
> 3. 一个实体类 *可以实现 多个接口*，但 *只能继承 一个抽象类*。



![[接口和抽象类的异同.png]]


## 接口的 定义 和 使用

- 接口用*关键字* **interface** 来定义。
    - `public interface 接口名{}`

- 接口 **不能实例化**。

- 接口和类之间是 *实现关系*，通过 **implements** *关键字*表示。
    - `public class 类名 implements 接口名{}`

- 接口的**实现类**（也叫做 *子类*）
    - 要么 **重写** 接口中的 *所有抽象方法*；
    - 要么 *本身也是抽象类*。

**注意1**：接口和类的实现关系，可以单实现，也 *可以多实现*。
- `public class 类名 implements 接口名1, 接口名2{}`

**注意2**：实现类还可以在 *继承一个类 的同时 实现多个接口*。
- `public class 类名 extends 父类 implement 接口名1, 接口名2{}`


### 练习

![[接口基本使用练习.png]]

实现代码：
*动物类*：
```java
public abstract class Animal {
	// 提取共性
	private String name;
	private int age;
	
	public abstract void eat(Animal animal); 
	
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	public int getAge(){
		return age;
	}
	
	@Override
	public String toString(){
		return "name: " + name + ", age: " + age;
	}
	
}
```

*游泳 接口*：
```java
public interface Swim{
	void Swimming();
}
```

*兔子类*：
```java
public class Rabbit extends Animal() {
	public Rabbit(){
	}
	
	public Rabbit (String name, int age) {
		super(name, age);
	}
	
	@Override
	public void eat(Animal animal){
		System.out.println(animal.age + "岁的" + animal.name + "在吃胡萝卜");
	}
}
```

*青蛙类*：
```java
public class Frog extends Animal implements Swim {
	public Frog() {
	}
	
	public Frog(String name, int age){
		super(name, age);
	}
	
	@Override
	public void eat(Animal animal){
		System.out.println(animal.age + "岁的" + animal.name + "在吃虫子");
	}
	
	@Override
	public void swimming(){
		System.out.println("蛙泳");
	}
}
```

*狗类*：
```java
public class Dog extends Animal implements Swim {
	public Dog() {
	}
	
	public Dog(String name, int age){
		super(name, age);
	}
	
	@Override
	public void eat(Animal animal){
		System.out.println(animal.age + "岁的" + animal.name + "在吃骨头");
	}
	
	@Override
	public void swimming(){
		System.out.println("狗刨");
	}
}
```

*测试类*：
```java
public class Test(){
	public static void main(String[] args){
		Rabbit rabbit = new Rabbit("兔子", 1);
		rabbit.eat(rabbit);
		
		Frog frog = new Frog("青蛙", 2);
		frog.eat(frog);
		frog.swimming();
		
		Dog dog = new Dog("狗", 3);
		dog.eat(dog);
		dog.swimming();
	}
}
```


## 接口中成员的特点

- **成员变量**
    - *只能是* **常量**
    - *默认* 修饰符：`public static final`

- **构造方法**
    - *没有*

- **成员方法**
    - *只能是* **抽象方法**
    - *默认* 修饰符：`public abstract`
    - **提示**：
        - *JDK7 以前*：接口中*只能*定义*抽象*方法。
        - *JDK8 的新特性*：接口中可以定义*有方法体*的方法。
        - *JDK9 的新特性*：接口中可以定义*私有*方法。 


## 接口和类之间的关系

- **类 和 类** 之间的关系：
    - *继承关系*
    - 只能 *单继承*，不能多继承，但是可以 *多层继承*。

- **类 和 接口** 的关系：
    - *实现关系*
    - 可以*单实现*，也可以*多实现*，还可以在*继承一个类的同时实现多个接口*。
        - 多实现时，要 *重写所有接口* 的抽象方法
            - **细节**：如果 *多个接口* 中有 *重名的方法*，我们 *只需要重写一次* 即可。
            ```java
            // 接口
            public interface Inter1{
	            void m1();
	            void m2();
            }
            public interface Inter2{
	            void m1();
	            void m2();
	            void m3();
            }
            // 实现类
            public class Test implements Inte1, Inter2{
	            @Override
	            public void m1(){
	            }
	            @Override
	            public void m2(){
	            }
	            // 以上重复的抽象方法只需要重写一次即可
	            @Override
	            public void m3(){
	            } 
            }
			```

- **接口 和 接口** 的关系：
    - *继承关系*
    - 可以*单继承*，也可以*多继承*
        - **细节**：如果 *实现类* 实现的是 *最下面的子接口*，需要 *重写所有* 的抽象方法
        ```java
        // 接口
        public interface Inter1{
	        void m1();
        }
        public interface Inter2{
	        void m2();
        }
        public interface Inter3 extends Inter1, Inter2{
	        void m3();
        }
        // 实现类
        public class InterImpl implements Inter3{
	        // 实现的是最下面的子接口，所以需要重写所有抽象方法
	        @Override
	        public void m1(){
	        }
	        @Override
	        public void m2(){
	        }
	        @Override
	        public void m3(){
	        }
        }
        ```



## 接口和抽象类的综合案例

![[接口和抽象类的综合案例1.png]]


**思维逻辑**（相对而言更好的）：
![[接口和抽象类的综合案例1：思维逻辑.png]]


代码：
```java
public class InterfaceTest {  
    public static void main(String[] args) {  
        TennisPlayer tennisPlayer = new TennisPlayer("乒乓球运动员", 20);  
        System.out.println(tennisPlayer);  
        tennisPlayer.study();  
        tennisPlayer.studyEnglish();  
  
        TennisCoach tennisCoach = new TennisCoach("乒乓球教练", 40);  
        System.out.println(tennisCoach);  
        tennisCoach.teach();  
        tennisCoach.studyEnglish();  
  
        BasketballPlayer basketballPlayer = new BasketballPlayer("篮球运动员", 21);  
        System.out.println(basketballPlayer);  
        basketballPlayer.study();  
  
        BasketballCoach basketballCoach = new BasketballCoach("篮球教练", 41);  
        System.out.println(basketballCoach);  
        basketballCoach.teach();  
    }  
}  
  
// 人类  
// 因为现在我不想让外界去直接创建人的对象  
// 因为直接创建顶层父类 人的对象 此时是没有意义的  
// 所以我就把他写为抽象的
abstract class Person0 {  
    private String name;  
    private int age;  
  
    public Person0() {  
    }  
  
    public Person0(String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
    @Override  
    public String toString() {  
        return "Person0{" +  
                "name='" + name + '\'' +  
                ", age=" + age +  
                '}';  
    }  
}  
  
// 运动员类  
abstract class Athlete extends Person0 {  
    // 学打乒乓球 / 打篮球  
    public abstract void study();  
  
    public Athlete() {  
    }  
  
    public Athlete(String name, int age) {  
        super(name, age);  
    }  
}  
  
// 教练类  
abstract class Coach extends Person0 {  
    // 教打乒乓球 / 打篮球  
    public abstract void teach();  
  
    public Coach() {  
    }  
  
    public Coach(String name, int age) {  
        super(name, age);  
    }  
}  
  
// 学英语接口  
interface StudyEnglish {  
    void studyEnglish();  
}  
  
// 乒乓球运动员类  
class TennisPlayer extends Athlete implements StudyEnglish {  
    public TennisPlayer() {  
    }  
  
    public TennisPlayer(String name, int age) {  
        super(name, age);  
    }  
  
    @Override  
    public void study() {  
        System.out.println("学打乒乓球");  
    }  
  
    @Override  
    public void studyEnglish() {  
        System.out.println("学英语");  
    }  
  
  
}  
  
// 篮球运动员类  
class BasketballPlayer extends Athlete {  
    @Override  
    public void study() {  
        System.out.println("学打篮球");  
    }  
  
    public BasketballPlayer() {  
    }  
  
    public BasketballPlayer(String name, int age) {  
        super(name, age);  
    }  
}  
  
// 乒乓球教练类  
class TennisCoach extends Coach implements StudyEnglish {  
    public TennisCoach() {  
    }  
  
    public TennisCoach(String name, int age) {  
        super(name, age);  
    }  
  
    @Override  
    public void teach() {  
        System.out.println("教打乒乓球");  
    }  
  
    @Override  
    public void studyEnglish() {  
        System.out.println("学英语");  
    }  
}  
  
// 篮球教练类  
class BasketballCoach extends Coach {  
    @Override  
    public void teach() {  
        System.out.println("教打篮球");  
    }  
  
    public BasketballCoach() {  
    }  
  
    public BasketballCoach(String name, int age) {  
        super(name, age);  
    }  
}
```

## JDK8开始接口中新增的方法

JDK7以前：接口中只能定义抽象方法。
JDK8的新特性：接口中可以定义有方法体的方法（默认、静态）。
JDK9的新特性：接口中可以定义私有方法。


### JDK8新特性：默认方法

由于程序版本更新，可能原本的接口需要新增几个方法，实现类也需要立刻修改，但写实现类的程序员现在可能不方便实现接口中新增的方法，代码就会报错。

因此 *想加新的规则，但又想让他们的代码不报错*，怎么办呢？
- 如果*接口里面的方法 可以有方法体*就简单了。
- 此时实现类就不需要立马修改了，等以后用到某个规则（方法）了，再重写就行了。

- **JDK8以后接口中新增的方法（默认方法）**
    - 允许在接口中定义*默认方法*，需要使用关键字`default`修饰。
        - *作用*：解决**接口升级**的问题 

接口中 *默认方法* 的 **定义格式**：
- 格式：`public default 返回值类型 方法名(参数列表){}`
- 范例：public *default* void show(){};

接口中默认方法的 **注意事项**：
- 默认方法 ***不是抽象方法***，所以 ***不强制被重写***。但是*如果被重写*，重写的时候 **子类方法 去掉** *default关键字*。但*调用不需要*。
- 接口中，public可以省略，default不能省略。
- 如果实现了多个接口，*多个接口*中存在*相同名字的默认方法*，子类不管用不用，*必须*对该方法进行*重写*（否则调用时不知道调用哪个）。


### JDK8新特性：静态方法

允许在接口中定义*静态方法*，需要用`static`修饰。

接口中 *静态方法* 的 **定义格式**：
- 格式：`public static 返回值类型 方法名(参数列表){}`
- 范例：public *static* void show(){};


接口中静态方法的 **注意事项**：
- 静态方法 *只能通过* **接口名调用**，不能通过 实现类名 或着 对象名调用。
- public可以省略，static不能省略。

接口中的 静态方法 **不能被重写**。

### JDK9新特性：

一些方法代码是*只为当前接口服务*的，并*不需要被其他类或接口调用*，所以可以定义成私有的。

私有方法分为两种：普通的私有方法，静态的私有方法。

接口中 *私有方法* 的 **定义格式**：
- 格式1：`private 返回值类型 方法名(参数列表){}`
- 范例1：*private* void show(){}
- 给*默认方法*服务的。

- 格式2：`private static 返回值类型 方法名(参数列表){}`
- 范例2：*private static* void method(){}
- 给*静态方法*服务的。



## 接口的应用

1. 接口代表*规则*，是*行为*的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。
   
2. **接口的多态**：如果一个 *方法的参数* 是一个 *接口*，那么我们 在调用这个方法的时候 就可以传递这个接口所有的 *实现类对象*。



## 接口适配器设计模式

**设计模式**（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的*总结*。

使用设计模式是为了*可重用代码*、让代码*更容易被他人理解*、保证代码的*可靠性*、程序的*重用性*。

**简单理解**：设计模式就是 *各种套路*。


- **适配器设计模式**：解决 *接口* 与 *接口实现类* 之间的 *矛盾问题*。
    - 也就是某个实现类 *不需要* 用到接口中*所有的抽象方法* 的矛盾问题。
    - 当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以使用适配器设计模式。


**步骤**：
1. **编写中间适配器类** XXXAdapter，**实现** *对应的接口*。
2. 对接口中的*抽象方法*进行 *空实现*。
3. 编写 **真正的实现类** XXXImpl，*继承 中间类*，并 **重写** *需要用到的方法*。
4. 为了*避免*其他类创建适配器类的对象，中间的 *适配器类* 用 **abstract**进行修饰。

*细节*：
如果真正的实现类已经继承了别的类（不能多继承），可以让那个父类继承中间适配器类（间接继承）。