

**1. 编写任务类（MyTask），实现Runnable接口：**
- 需求：
    - 自定义线程池练习，这是任务类，需要实现Runnable接口
    - 包含任务编号，每一个任务执行时间设计为 0.2秒

```java
/**  
 * 自定义线程类
 * 
 * 需求：  
 * 自定义线程池练习，这是任务类，需要实现Runnable接口  
 * 包含任务编号，每一个任务执行时间设计为 0.2秒  
 */  
public class MyTask implements Runnable {  
    private int id;  
	
    // 由于run方法是重写接口中的方法，因此id这个属性初始化可以利用构造方法完成  
    public MyTask(int id) {  
        this.id = id;  
    }  
	
    @Override  
    public void run() {  
        // 获取线程的名字  
        String name = Thread.currentThread().getName();  
        System.out.println("线程：" + name + "即将执行任务：" + id);  
		
        // 为了模拟任务执行时间，所以利用休眠200毫秒来完成  
        try {  
            Thread.sleep(200);  
        } catch (InterruptedException e) {  
            throw new RuntimeException(e);  
        }  
        System.out.println("线程：" + name + "完成了任务：" + id);  
    }  
}
```
   

**2. 编写线程类（MyWorker），用于执行任务，需要持有所有任务：**
- 需求：
    - 编写一个线程类，需要继承Thread类，
    - 设计一个属性，用于保存线程的名字
    - 设计一个集合，用于保存所有的任务

```java
/**  
 * 任务类
 * 
 * 需求：  
 * 编写一个线程类，需要继承Thread类，  
 * 设计一个属性，用于保存线程的名字  
 * 设计一个集合，用于保存所有的任务  
 */  
public class MyWorker extends Thread {  
  
    private String name;    // 保存线程的名字  
    private List<Runnable> tasks;   // 保存所有任务  
  
    // 利用构造方法，给属性赋值  
    public MyWorker(String name, List<Runnable> tasks) {  
        super(name);  
        this.tasks = tasks;  
    }  
  
    @Override  
    public void run() {  
        // 判断集合中是否有任务，只要有，就一直执行任务  
        while (tasks.size() > 0) {  
            Runnable r = tasks.remove(0);  
            r.run();  
        }  
    }  
}
```



**3. 编写线程池类（MyThreadPool），包含提交任务，执行任务的能力：**
```java
/**  
 * 这是自定义的线程池类  
 * <p>  
 * 成员变量：  
 * 1.任务队列   集合  需要控制线程安全问题  
 * 2.当前线程数量  
 * 3.核心线程数量  
 * 4.最大线程数量  
 * 5.任务队列的长度  
 * <p>  
 * 成员方法：  
 * 1.提交任务：将任务添加到集合中，需要判断是否超出了任务总长度  
 * 2.执行任务：判断当前线程的数量，决定创建核心线程还是非核心线程  
 */  
public class MyThreadPool {  
  
    // 1.任务队列   集合  需要控制线程安全问题  
    private List<Runnable> tasks = Collections.synchronizedList(new LinkedList<>());  
    // 2.当前线程线程池中的线程数量  
    private int num;  
    // 3.核心线程数量  
    private int coreSize;  
    // 4.最大线程数量  
    private int maxSize;  
    // 5.任务队列的长度  
    private int workSize;  
  
    public MyThreadPool(int coreSize, int maxSize, int workSize) {  
        this.coreSize = coreSize;  
        this.maxSize = maxSize;  
        this.workSize = workSize;  
    }  
  
    // 1.提交任务：  
    // 将任务添加到任务队列中，需要判断是否超出了任务队列总长度  
    public void submit(Runnable task) {  
        // 判断当前集合中任务的数量，是否超出了最大任务数量  
        if (tasks.size() >= workSize) {  
            System.out.println("任务：" + task + "被丢弃了...");  
        } else {  
            tasks.add(task);  
  
            // 执行任务  
            execTask(task);  
        }  
    }  
  
    // 2.执行任务  
    private void execTask(Runnable task) {  
        // 判断当前线程池中的线程总数量，是否超出了线程数  
        if (num < coreSize) {  
            num++;  
            new MyThread("核心线程：" + num, tasks).start();  
        } else if (num < maxSize) {  
            num++;  
            new MyThread("非核心线程：" + num, tasks).start();  
        } else {  
            System.out.println("任务：" + task + "被缓存了...");  
        }  
    }  
  
}
```



**4. 编写测试类（MyTest），创建线程池对象，提交多个任务测试：**
```java
/**  
 * 测试类  
 * 1.创建线程池类对象  
 * 2.提交多个任务    循环  
 */  
public class MyTest {  
    public static void main(String[] args) {  
        // 1.创建线程池类对象  
        MyThreadPool pool = new MyThreadPool(2, 4, 20);  
		  
        // 2.提交多个任务  
        for (int i = 0; i < 30; i++) {  
            // 生成一个任务，并提交给线程池  
            MyTask task = new MyTask(i + 1);  
            pool.submit(task);  
        }  
    }  
}
```