
我们要想自定义线程池，必须先了解线程池的工作原理，才能自己定义线程池；
这里我们通过 观察Java中 *ThreadPoolExecutor* 的源码来学习线程池的原理。


1. `int corePoolSize`：**核心线程数**。
    - 当我们有一个任务提交到线程池中时，
        - 如果当前运行的线程的数量 *没有达到 核心线程的数量*，那么*直接就 新开一个线程*来执行这个任务。
        - 如果达到了，就先去任务队列。

2. `int maximumPoolSize`：**最大线程数**。
    - 可以控制当前程序里面允许创建出来的最大线程数量，从而保证系统可以正常运行。
    - 这里面 *包含核心线程数*。

3. `long keepAliveTime`：**最大空闲时间。临时线程 存活时间**。
    当一个*非核心线程* 不使用的时候，允许空闲的时间。超过后 线程池会*回收*这个线程。
    4. `TimeUnit unit`：时间单位。
        枚举类型，定义了一些常量用来定义：时、分、秒 以及 毫秒 等等。

5. `BlockingQueue<Runnable> workQueue`：**阻塞队列。任务队列**。
    - 当**核心线程都在干活时**，再来任务的话，它*不会 立刻就创建新线程*，它会把任务*先加到任务队列* 中。只有当 **任务队列加满后**，再来任务时，*才* 会继续*创建新的非核心线程* 来为这个任务服务，但*不会超过 最大线程数*。
    - 对线程池更细腻控制的一个点。

6. `ThreadFactory threadFactory`：**线程工厂**。
    - 接口。
    - 允许我们自己参与创建线程的过程。用我们的代码来创建线程。
    - 手动构建的 *好处/目的*：可以给线程*指定一个名称*。当出现问题时可以快速定位错误位置。

7. `RejectedExecutionHandler handler`：**拒绝策略。饱和处理机制**。
    - 当达到最大线程数量时，如果还有任务要进线程池，那么需要采取哪些措施。
    - 比如把这个任务*丢弃*或让其*等待*。


```java
public ThreadPoolExecutor(int corePoolSize,    // 核心线程数
                          int maximumPoolSize,    // 最大线程数
                          long keepAliveTime,    // 最大空闲时间
                          TimeUnit unit,    // 时间单位
                          BlockingQueue<Runnable> workQueue,  // 阻塞队列
                          ThreadFactory threadFactory,    // 线程工厂
                          RejectedExecutionHandler handler  // 拒绝策略
                          ) {
    
}
```

通过下面的场景来理解这些参数：
![[2. 理解七个参数.png]]