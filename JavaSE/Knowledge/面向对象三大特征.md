
## 封装

> 对象代表什么，就得封装对应的数据（属性），并提供数据对应的行为（方法）


- **例如：**

  - 人画圆，针对这个需求进行面向对象设计  
    两个对象：人对象和圆对象  
    人只是调用了圆画自己的方法（方法：画圆），圆根据半径自己画了一个圆（方法：根据半径画圆）
  
  - 人关门
    人对象，门对象  
    人只是提供了作用力这个行为（方法：让门关上），门自己关上的（方法：开门 和 关门）

  - 鲨人
    张三 对象，被害人对象  
    xx持刀行凶（方法： 鲨人），造成了xx死亡的后果（方法：活着 和 死亡）

```java
// 人关门
public class people{  
    String name;  
    int age;  
    public void f(){  
        System.out.println("让门关上");  
    }  
}  
public class door{  
    public void open(){  
        System.out.println("开门");  
    }  
    public void close(){  
        System.out.println("关门");  
    }  
}
```


- **封装调用**  
  - String s = "wadsadafadad";          // String对象代表字符串  
								    // 用 String对象 封装要处理的字符串  
  - int length = s.length();    // 调用 String对象 中获取长度的方法  
    System.out.println(length);  
    
    String upperCase = s.toUpperCase();     // 调用 String对象 中获取大写的方法  
    System.out.println(upperCase);


- **private 关键字**  

  - private 是一个 权限修饰符(私有化)   可以修饰成员(成员变量和成员方法)  被 private 修饰的成员 只能在本类中 才能访问。  所以一些成员数据的判断语句只能在本类中编写 

  - 可以避免输入一些错误的数据

  - 针对于每个私有化的成员变量，都要提供 setXxx(参数)和 getXxx() 方法  方法用 public 修饰  

  - set方法：给成员赋值(要参数)
  - get方法：对外提供成员变量的值(要返回值)


> JavaBean 是一个封装类
- *标准的JavaBean类*
  1. 类名要见名知意(驼峰命名法)  
  2. 成员变量使用 private 修饰  
  3. 提供至少两个构造方法    无参构造方法 和 带参构造方法  
  4. 成员方法  提供每一个成员变量对应的 setXxx() 和 getXxx();   如果还有其他行为，也需要写上

- 快捷键
  - alt + insert / alt + fn + insert 快速生成构造方法

- 插件
  - Ptg   1秒生成标准JavaBean
  - 操作： 右键 选择菜单最下面



---



## 继承

> object 类是所有类的父类，每一个类都直接或间接的继承于Object
> 如果没写继承谁，会默认继承 Object 类

什么是继承：利用已有的类快速创建新的类的机制。

1. **继承**
   - Java中提供了一个关键字 **extends** , 用这个关键字，我们 **可以让一个类和另一个类建立起继承关系**
   `public class Student extends Person{}`
   - Student 称为 **子类（派生类）** ，Person 称为 **父类（超类或基类）**。


2. **使用继承的好处**
   - 可以把多个子类中重复的代码抽取到父类中，*提高代码的复用性*
     - 封装共有的属性和行为 —— 实现代码复用
   - 子类可以得到父类的属性和行为，子类可以直接使用
   - 子类可以在父类的基础上，*增加其他的功能*，使子类更强大
   - 为所有的子类提供了统一的类型 —— 向上造型 (实现代码复用)


3. **继承的特点**
   - Java只支持 *单继承 (单根性)*，不支持多继承，但支持*多层继承 (传递性)*
     - `A extends B   B extends C`
       我们称 B 是 A 的 直接父类 ， C 是 A 的 间接父类
   - Java中所有的类都直接或间接的继承于Object
   - 子类只能访问父类中 *非私有* 的成员


4. **什么时候用继承**
    - 当类与类之间，*存在相同（共性）的内容*，并满足*子类是父类的一种*，就可以考虑使用继承，来优化代码
        - *隐含的意味*：一个父类中所有的子类需要是同一种事物。

     - 父类：person            属性：姓名，年龄
       - 子类：Student           属性：
       - 子类：Teacher           属性：
     
     - 父类： Employ          属性：姓名，工资
       - 子类：Manager          属性：管理资金
       - 子类：Coder                属性：
     
     - 父类：他俩没有一种父类能一起描述（子类是父类中的一种才可以）
       - 子类：Coder                属性：id，名字，年龄
       - 子类：Phone               属性：id，名字，价格


5. **子类到底能继承父类中的哪些内容**
   - 误区1：父类私有的东西，子类就无法继承
   - 误区2：父类中非私有的成员，就被子类继承下来了

|  成员  |  非私有  |  私有   |
| :--: | :---: | :---: |
| 构造方法 |   ×   |   ×   |
| 成员变量 |   √   |   √   |
|      | 在虚方法表 | 非虚方法表 |
| 成员方法 |   √   |   ×   |

   1. 构造方法无法被继承的原因
       - 构造方法是  `public 类名(){}`，父子类的类名不同，如果继承就会违背构造方法的原则
       - 如果子类没写构造方法，系统默认自动添加一个空参构造

   2. 成员变量的继承
      - 在加载字节码文件时 *会先把父类的也加载到方法区*
      - 子类在创建对象时，在 *堆中新建的空间会分成两份*，一份存父类的成员变量，一份存子类的成员变量
      - 子类对象在赋值时，先在堆内存对象小空间中自己的那部分找，找不到再到父类里面找
      - *父类私有化的成员变量*，虽然继承下来了，但不能直接调用
        - 可以在子类对象内存中查找到，但是不能直接赋值
        - 继承和调用不混。继承是父类有的，子类也就有一份一模一样的
        - 需要用公共方法 ( `set()和get()` ) 访问

   3. 成员方法的继承
      - **只有父类中的 虚方法表 中的方法才能被子类继承**
      - **虚方法：** *非 private，非 static，非 final*
      - **虚方法表：** *爷爷类* 有一个虚方法的表，*父类的虚方法表*在爷爷类的虚方法表的基础上，添加自己类中的虚方法，*子类*再在父类的基础上添加自己类中的虚方法（子类包含所有父类爷爷类的虚方法）。
      - *所有 属于同一类型的所有对象 共用一张虚方法表。*
      - 如果方法 *只被 final 修饰*，
         1. 修饰*类*不允许被继承。修饰*变量*表示不能被修改。
         2. 是 *可以被继承和重载的，但是不能被重写*，但它依然*不是虚方法*。
         3. 如果同时被 private 修饰，则不能被继承。
      - 只被 *static* 修饰的方法：
         1. 父类中的静态方法*可以被继承*、但*不能被子类重写*。
         2. 如果在子类中写一个和父类中*一样*的静态方法，那么该静态方法由该子类*特有*，两者不构成重写关系。
      
      - 子类调用方法时会先看是不是虚方法：（*提高效率*）
        - 如果调用的*是虚方法*的话，就不需要 自己类→父类→爷爷类 挨个找了，直接调用虚方法表里的
        - 如果调用的*不是虚方法*的话，*挨个*往自己类,父类,爷爷类上面找（*没有继承*方法，而是继承中的*查找关系*，被 private 修饰的方法不能被访问。）

</br>

6. **继承中：成员的访问特点**

   1. 继承中：成员变量的访问特点
      - *就近原则：谁离我近，我就用谁*
      - 如果出现了*重名*的*成员变量*
        - sout( name );     从局部位置开始往上找
        - sout( this.name );     从本类成员变量位置开始往上找
        - sout( super.name );     从父类成员变量位置开始往上找
      - 如果在整个继承体系里都找不到，就会报错
    ```java
    public class Fu{
		String name = "Fu";
	}
	public class Zi extends Fu{
		String name = "Zi";
		public void ziShow(){
			String name = "zishow";
			System.out.println(name);     // "zishow"
			System.out.println(this.name);     // "Zi"
			System.out.println(super.name);     // "Fu"
		}
	}
    ```

   2. 继承中：成员方法的访问特点
      - *直接调用 或 this.调用 满足就近原则：* 谁离我近，我就用谁
        - 先在本类（子类）中查找是否有该方法，若找到了就调用本类的，若没有则会调用父类中继承下来的方法
      - *super调用：* 直接访问父类
        - 不会查找本类，直接去父类调用

   3. 继承中：构造方法的访问特点
      - 父类中的构造方法不会被子类继承
      - 子类中所有的构造方法 *默认先访问父类中的无参构造*，再执行自己
        1. **为什么？**
           - 子类在初始化的时候，有可能会用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
           - 子类初始化之前，一定要调用父类构造方法 *先完成父类数据空间的初始化。*
        2. **怎么调用父类的构造方法？**
           - 子类构造方法的第一行语句默认为：*super ();   不写也存在，且必须在第一行。*
           - 如果*想调用父类的有参构造*，*必须手动手写 super* 进行调用。 


7. **方法的重写(Override)：**

   - *只发生在有 继承关系 的父子类中*
   - 子类把从父类继承下来的虚方法表里面的方法进行覆盖了，这才叫重写。
   - 当父类的方法不能满足子类现在的需求时，需要进行方法重写。
   - **书写格式：** 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。
   - 重写的方法*不允许抛出新的异常 或着 更加宽泛的异常*。
   
   - **@Override** 重写注解
     1. @Override是放在重写后的方法上，*校验子类重写时语法是否正确*。
     2. 加上注解后如果注解下面有*红色波浪线*，表示语法错误。
     3. 建议重写方法都加 @Override 注解，代码安全，优雅！
     4. 如果发生了重写，就会*覆盖*父类继承下来的虚方法表中的原方法。
     5. 重写时*直接写方法名 + 回车*，就会自动注解@Override。
     
   - **注意事项和要求**
     1. 重写方法的 *名称、形参列表* 必须与父类中的一致。
     2. 子类重写父类方法时，*访问权限 子类必须 大于等于父类* (private < 默认 < protect < public )
     3. 子类重写父类方法时，*仅当返回值为* **类 类型时**，*才可修改返回值类型，且必须与父类相同 或  父类的子类* 。
     4. 只有被添加到*虚方法表*中的方法才能被重写
     5. 建议：重写的方法尽量和父类保持一致
     6. 声明为 *final* 的方法不能被重写
     7. 声明为 *static* 的方法不能被重写，但 *可以重新声明*（父类的同名方法会被隐藏）。


8. **继承中的查找关系：**
   
   - 调用输出时*首先看子类是否有该属性*，如果子类有这个属性，并且可以访问则返回信息，
   - 如果子类没有，则*继续往上级的父类查找*，看父类有没有这个属性，如果父类有该属性并且可访问，就返回信息，
   - 如果父类没有就按照向上查找规则继续找上级父类，直到object类，若都没有，则报错；
   - 当查找到这个属性，但是却被 private 修饰不能直接访问时，直接报错。而 *不是发现不能访问而继续向查找*，因为按照查找关系，已经找到这个属性了。
     *被 private 修饰的变量需要 get() 方法查找*，*被private 修饰的方法则不能被访问*。



---



## 多态


1. **多态的前提**
   
   1. 有 *继承/实现* 关系。
   2. 有 *父类变量 引用指向 子类对象*。`Fu f = new Zi();`
   3. 有 *方法重写*。


2. **什么是多态**
   
   - *就是对象的多种形态*
   - *同类型的对象，表现出的不同形态*
   > 	 学生形态         对象
   > Student  s  = new Student();
   > 
   > 	人的形态         对象
   > Person  p	=  new Student();


3. **多态的应用场景（好处）**
   
   - 当一个方法需要的 *形参是不同类型* 时，可以使用它们 *共同的父类* 作为参数
    - *可以接收所有的子类*，体现多态的扩展性与便利
    - 根据传递对象的不同，可以调用不同的同名方法

    - 当一个方法需要 *返回的是不同类型* 时，可以在*返回值类型处写它们共同的父类*
   
    - 在多态形式下，*右边的对象可以实现解耦合*，便于扩展和维护。
        
        > Person  p  =  new  Student ( );
        > p . work( );      
        > // 业务逻辑发生改变时，后续代码无需修改
        > // 例如：后续不想让学生工作了，想让老师去工作，只需要修改后面的对象即可


4.**多态的表现形式：**

   `父类类型 对象名称 = 子类对象;`
   
   - 例如:
     > Person  p  =  new  Student( );
     > 或：
     > Student  s  =  new  Student();
     > Person  p  =  s ;

   - **这就是向上造型（自动类型转换）**

5. **多态调用成员的特点**
   
   - **变量调用**：编译看左边，运行也看*左边*。
   - **方法调用**：编译看左边，运行看*右边*
     
     - *编译看左边*：javac编译代码的时候，会看左边的父类中有没有这个  变量  或  方法，
        如果有，编译成功，如果没有，编译失败。
     - *运行看左边  /  右边*：java运行代码的时候，实际获取的就是左边父类中成员变量的值 或 调用的是右边子类里的方法。
   
   - **理解**：
     
     - `Animal a = new Dog();`
	     - Animal类型的变量 **指向/引用** 了Dog类型的对象
     - 等于是把子类的东西都给了Animal类型的 a
     - 现在是用 a 去调用变量和方法
     - 而 a 是Animal类型的，所以*默认*都会先到Animal这个类中去看有没有
     - *成员变量*：在子类的对象中，*会把父类的成员变量也继承下来*，所以*谁调用返回谁*的 name（父类调用，所以都是看父类的）。
     - *成员方法*：如果*子类对方法进行了重写*，那么在*虚方法表*中时会把父类的方法进行*覆盖*的。
     - *其实都是在子类中进行调用。*
     
     ```java
     public class Test{
	     Animal a = new Dog();
	     // 变量调用 都看左边
	     System.out.println(a.name);     // 动物
	     
	     // 方法调用 运行看右边
	     a.show();     // "Dog--show"
     }
     
     class Animal{
	     String name = "动物";
	     
	     public void show(){
		     System.out.println("Animal--show")
	     }
     }
     
     class Dog extends Animal{
	     String name = "狗";
	     
	     @Override
	     public void show(){
		     System.out.println("Dog--show");
	     }
     }
	  ```


6. **多态的优势和弊端**
   
   1. 多态的**优势**
      
      - 在多态形式下，*右边的对象可以实现解耦合*，便于扩展和维护。
        
        > Person  p  =  new  Student ( );
        > p . work( );      
        > // 业务逻辑发生改变时，后续代码无需修改
        > // 例如：后续不想让学生工作了，想让老师去工作，只需要修改后面的对象即可
	
      - **定义方法时，使用父类型作为参数，可以接收所有的子类对象**，体现多态的扩展性和便利。

   2. 多态的**弊端**
      
      **不能调用子类特有的功能(方法)**
        
        - 调用方法时：编译看左边，运行看*右边*
        - 左边父类压根没有，强行写的话就会报错
        
        - **解决方案**：把调用者再变回子类型
            
            - `子类类型 变量名称 = (子类类型) 父类型对象;`
            
            - *可以转换成真正的子类类型，从而调用子类独有的功能(方法)。*
            
            - **这就是向下造型（强制类型转换）**
                
                - 细节：
                    - 转换类型与真实对象类型不一致会报错。
                        - 要转的父类变量所指向的子类对象  与  要转换的子类类型不一致，就会报错，所以*只能转成创建时的子类的类型*
                        - 转换的时候可以用 *instanceof关键字* 判断，是否为这个类型，然后再强转