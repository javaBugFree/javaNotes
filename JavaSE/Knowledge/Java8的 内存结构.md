

> [!tip] 网站参考
> [终于搞懂了Java8的内存结构，再也不纠结方法区和常量池了！-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1810426)
> 


![[Java8的内存结构.png]]


### **Java堆（Java Heap）**

java堆是JVM内存中最大的一块，由所有线程共享,是由垃圾收集器管理的内存区域，主要存放对象实例，当然由于java虚拟机的发展，堆中也多了许多东西，现在主要有：
- *对象实例*
    - 类初始化生成的对象
    - 基本数据类型的数组也是对象实例
- *字符串常量池*
    - 字符串常量池原本存放于方法区，jdk7开始放置于堆中。
    - 字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张string table
- *静态变量*
    - 静态变量是有static修饰的变量，jdk7时从方法区迁移至堆中
- *线程分配缓冲区*（Thread Local Allocation Buffer）
	- 线程私有，但是不影响java堆的共性
    - 增加线程分配缓冲区是为了提升对象分配时的效率

java堆既可以是固定大小的，也可以是可扩展的（通过参数-Xmx和-Xms设定），如果堆无法扩展或者无法分配内存时也会报OOM。

<hr>

### **方法区(Method Area)**

方法区绝对是网上所有关于java内存结构文章争论的焦点，因为方法区的实现在java8做了一次大革新，现在我们来讨论一下：

方法区是*所有线程共享*的内存，
在*java8以前* 是放在JVM内存中的，由*永久代*实现，受JVM内存大小参数的限制，
在*java8中* 移除了永久代的内容，方法区由*元空间*(Meta Space)实现，并**直接放到了本地内存中**，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM），*并且将原来放在方法区的 字符串常量池 和 静态变量都转移到了Java堆中*，方法区与其他区域不同的地方在于，方法区在编译期间和类加载完成后的内容有少许不同，不过总的来说分为这两部分：

**类元信息（Klass）**
- 类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）
- 常量池表（Constant Pool Table）存储了类在编译期间生成的字面量、符号引用(什么是字面量？什么是符号引用？)，这些信息在类加载完后会被解析到运行时常量池中

**运行时常量池（Runtime Constant Pool）**
- 运行时常量池主要存放在类加载后被解析的字面量与符号引用，但不止这些
- 运行时常量池具备动态性，可以添加数据，比较多的使用就是String类的intern()方法