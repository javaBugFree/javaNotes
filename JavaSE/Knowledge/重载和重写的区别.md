
## 重载和重写的区别

- 重写：发生在*父子类*中，方法名*相同*，参数列表*相同*，返回类型 *必须相同*.
- 重载：发生在*本类*中，   方法名*相同*，参数列表*不同*，返回类型 *可以不同（不影响）*.

| 区别点  | 重载方法 |           重写方法            |
| :--: | :--: | :-----------------------: |
| 方法名  |  相同  |            相同             |
| 参数列表 | *不同* |           *相同*            |
| 返回类型 | 不影响  |           *相同*            |
|  异常  | 不影响  | *可以减少或删除，一定不能抛出新的或更上级的异常* |
| 访问权限 | 不影响  |       *不能做出更严格的限制*        |


<hr>


## 重载(Overload)

**重载(overloading)** ：是在 *一个类里* 面。
- 方法名字*相同*，而 参数列表*不同*。
- 返回类型 *可以不同*，*不影响*。
- 访问修饰符*可以修改*。
- *可以* 声明新的或更广的检查异常。

> [!warning] 注意
> - 每个重载的方法（或着构造函数）都必须有一个*独一无二的参数类型列表*。
> - 最常用的地方就是构造器的重载。
> 


## 重写(Override)

**重写(Overriding)**：*子类对父类* 的 *允许访问的方法* 的 *实现过程* 进行重新编写。
- 方法名*相同*，参数也*相同*。
- 返回值类型*必须相同*。
- 访问权限*不能比父类中的低*。
- *不能* 抛出新的或更广的检查异常。
- *可以*抛出任何*非强制性异常*，无论被重写的方法是否抛出异常。
    - *不能*抛出新的*强制性异常*，或着比被重写方法声明的更广泛的强制性异常。



> [!example] 重写规则
> 
> 父类的 **成员方法** 只能被它的*子类* 重写；
> 父类的 **构造方法** *不能被重写*；
>
> 如果 *不能继承* 一个方法，则 *不能重写* 这个方法；（虚方法表）
> 
> 声明为 **final** 的方法不能被重写；
> 声明为 **static** 的方法不能被重写，但可以*再次声明*；
> 
> 子类和父类 **在同一个包** 中，那么子类 *可以* 重写父类所有 *除了private 和 final* 的方法；
> 子类和父类 **不在同一个包** 中，那么子类 *只能* 重写父类的声明为 *public 和 protected* 的*非 final* 方法；










