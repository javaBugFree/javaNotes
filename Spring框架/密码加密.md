
## 关于密码加密

用户的密码 **必须** *经过算法进行编码(encode)*，然后将编码结果存储到数据库中，后续，当需要验证密码时，也使用同样的编码过程对用户后续提交的密码再次进行编码，并与此前存入数据库中的密码进行对比，以此判断用户的密码是否正确。
> 编码：可作为动词，将原始数据经过某种算法，运算得到另一个数据，即可称之为"编码"

用户使用的**原始密码**通常称之为 “*原文*”，或 “*明文*”，经过**编码后**的结果称之为 “*密文*”。

目前，主流的用于解决各种应用场景的算法都不需要单独设计，有许多成熟的算法可以直接使用，并且，这些算法都有非常简单API。

对密码的原文进行编码时，**不可以**使用加密算法！*这类算法都是可以 逆向运算 的*，主要用于保障数据传输过程的安全，并不能保障存储下来的密码的安全！

- 推荐使用 **消息摘要算法** 或其他 **哈希算法**，用于对密码的原文进行编码，这些算法都是**不可逆向运算的**，即使算法类型、运算参数、密文全部被泄露，也不可能被计算得到密码的原文。
- *常见*的消息摘要算法有：
    - MD（Message Digest）系列：
        - MD2（128位算法）
        - MD4（128位算法）
        - MD5（128位算法）
    - SHA（Secure Hash Algorithm）家族：
        - SHA（SHA-1，160位算法）
        - SHA-256（256位算法）
        - SHA-384（384位算法）
        - SHA-512（512位算法）

- 消息摘要算法的*主要特征*有：
    - 使用同一种算法时，如果*消息相同，摘要一定相同*。
    - 使用同一种算法时，*无论消息多长，摘要的长度是 固定的*。
        - 长度主要看由多少位组成的算法，例如，128位算法结果为128个二进制位（128个0或1），一般API会将其转换为十六进制即36位。
    - 使用同一种算法时，如果*摘要不同，消息极大概率不会相同*。
        - 必然存在n种不同的消息，对应的摘要是完全相同的。
            例如：93 / 10 >>>9 ， ?? / 10 >> 9  ??不一定是93

以MD5算法为例，是128位算法，其运算结果有340282366920938463463374607431768211456种可能。
当然，如果算法类型、运算参数、密文全部被泄露，破解者仍可以通过 **穷举式的暴力破解** 来“试”出密码的原文！

为了进一步保障密码安全，应该要求用户使用安全强度更高的密码！
可通过键盘输入的大写字母、小写字母、数字、符号统称为“可打印字符”，共95种，如果用户使用6位长度的密码，将有约7350亿种不同的排列组合，则破解者最多需要运算7350亿次才可以保证100%的 “试” 出用户的原始密码，如果用户使用8位长度的密码，将有约6634万亿种不同的排列组合。所以，使用安全强度更高的密码，可以明显提高穷举式的暴力破解的难度！
参考数据：普通家用电脑每秒可以执行300万至1000万次MD5运算，换算为每小时约可执行1080亿次至3000亿次MD5运算。

另外，在网络上，有一些平台使用数据库记录了一些明文与密文的对应关系，对于通过常见算法进行编码的密文，能够实现 “反查式” 的 “破解”。但是，这些平台能够收录的数据量是非常有限的，如果某个平台需要记录所有8位长度的明文与密文的对应关系，
在不适用预计算的哈希链的情况下，需要记录6634万亿条数据，几乎是不可能的！





## MD5算法

在Spring项目中，提供了API `DigestUtils.md5DigestAsHex`

例如：
```java
String rawPassword = "123456";
String encodePassword = DigestUtils.md5DigestAsHex(
		rawPassword.getBytes());
System.out.println("原文：" + rawPassword);
System.out.println("密文：" + encodePassword);
```