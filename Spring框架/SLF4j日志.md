
在开发实践中，通常是禁止使用`System.out.println()`这种语句输出信息的，主要原因有：
- **不易控：** 在开发过程中，可能会通过这样的语句输出*某些变量值*，或输出*程序的执行过程*，这些输出的内容可能*仅适用于开发过程*中。
  当项目实际部署上线，就不应该甚至不允许输出这些内容，因为输出的变量值*可能是敏感信息*，或程序的执行过程*不应该被暴露出*来。
- **执行效率低下**：
    - 字符串的拼接

在Spring Boot项目中，基础依赖项（`spring-boot-starter`）中*已经包含了* **日志相关的依赖项**，可以直接使用日志框架来输出信息。

- 在**添加了 Lombok框架 后**，在任何类的声明上，添加`@Slf4j`注解，则编译器会自动声明一个名为 **log** 的*变量*，所以，可以在类中通过此变量来输出日志。
    - 例如：`log.info("123");`
- 如果**没有使用Lombok**的话，可以*手动声明* 一个*Logger类型* 的变量
    - 例如：`private static Logger logger = `


在日志框架中，根据日志信息的重要程度，*从不太重要，到非常重要*，划分了几个等级，依次是：
- `trace`：跟踪信息。程序执行的流程。敏感！
- `debug`：调试信息。值的变化。敏感！
- `info`：一般信息。不介意被别人看到的。
- `warn`：警告信息。
- `error`：错误信息
在调用`log`变量的方法来输出日志时，有以上5个级别对应的方法，调用不同的方法，就会输出不同级别的日志。
```java
@Slf4j  
@SpringBootTest  
public class Slf4jTest {  
      
    @Test  
    void test() {  
        log.trace("输出了【trace 跟踪】级别的信息");  
        log.debug("输出了【debug 调试】级别的信息");  
        log.info("输出了【info 一般】级别的信息");  
        log.warn("输出了【warn 警告】级别的信息");  
        log.error("输出了【error 错误】级别的信息");  
    }  
}
```

当配置为某个显示级别时，只会 *显示* **此级别** *及* **更重要级别** *的日志*！

- 在**没有加载Spring Boot**的情况下，日志的 *默认显示级别* 是 `debug`。
- 如果**加载了Spring Boot**（例如在测试类上添加了 `@SpringBootTest` 注解），日志的*默认显示级别*是 `info` ，则只会显示 `info`、`warn`、`error` 级别的日志，不会显示 `trace`、`debug` 级别的日志。


### 指定默认日志显示级别

在Spring Boot项目中，可以在**配置文件**（**application.properties / application.yml / 相关Profile配置**）中配置 `logging.level.包名【.类名】`属性，以*指定 某个包下 的 所有类* 的 **默认日志显示级别**，此**属性的值**为5个级别中的*某一个*。
例如：在 **application-dev.yml** 中添加配置：（另外，可以在其他Profile配置中为日志的显示级别配置不同的值）
```yml
logging:
  level:
    com.example.csmall.product: trace
```

**提示：** 当配置包名时，*不必把包名配置得特别具体*，可以作用于其子包下的所有类。但是，必须*至少配置1级包*，，例如配置到 **com** 这一级包，不可以完全不配置包名。

*注意*：当前项目中添加得所有依赖项，也是当前项目得一部分，不应该将包名配置得过于简单，例如只是用 `com` 作为配置的包名，可能有些依赖项也是在这个包下的。

**提示：** Mybatis框架会生成各Mapper接口的对象，这些对象在执行SQL语句时，也会输出日志，是`trace`和`info`级别的日志，当把日志的显示级别设置为较低的级别时，可以看到这些日志。


### 输出的信息包含变量值

在调用日志的方法时，如果*输出的信息*中**包含变量值**，推荐使用 `trance(String message, Object... args)` 方法（其他级别也是同样参数列表的方法），
在 `String message`参数中，可以使用 `{}` 作为占位符，表示此处是一个变量值，然后，通过`Object... args`依次传入各占位符对应的值，例如
```java
int x = 1;  
int y = 2;  
// 传统做法  
System.out.println("x = " + x + ", y = " + y + ", x + y = " + (x+y));  
// 使用日志输出变量的做法  
log.info("x={}, y={}, x + y={}", x, y, x+y);
```
以上使用**日志输出**时，*不会涉及到 字符串的拼接*，所以，执行效率会更高，并且，以上方法的*第一个参数是 字符串常量*，是存在*字符串常量池*中的，也可以一定程度上提高执行效率。

- 另外，**SLF4j**其实是一种*日志框架的 标准*，具体的日志相关功能并不是由它实现的，
    - 通常，是使用 **log4j** 或 **logback** 这些*日志框架* 来实现具体功能的。
    - *SLF4j* 提供了这些日志框架向SLF4j标准的转换。
    - 一种是标准，一种是实现。*类似于 接口和实现类 的关系*。

![[日志框架.png]]


- 使用规范：
    - 《阿里巴巴Java规范》里的 *日志规约*。