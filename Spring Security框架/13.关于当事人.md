
通常，当事人信息中应该*至少包含* **用户的ID和用户名**，而认证信息（`Authentication`）中的当事人（`Principal`）的类型被设计为`Object`，所以，你可以使用*任何类型的数据*作为当事人！则可以自定义类封装用户的ID和用户名！  
  
1. 在项目的根包下创建`security.LoginPrincipal`类，例如：  
```java  
@Data  
public class LoginPrincipal implements Serializable {  
  
    /**  
	 * 当事人的ID  
	 */private Long id;  
	  
	/**  
	 * 当事人的用户名  
	 */  
	private String username;
}  
```  
  
2. 在解析JWT时，将解析结果处理为期望的类型，例如：  
```java  
// 尝试解析JWT  
String secretKey = "dadjasdhasahiuawwkjawhfiawyuawakshdiawy"; 
// 获取Payload部分的claims数据
Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();  
  
Long id = claims.get("id", Long.class); // 期望的类型  
String username = claims.get("username", String.class); // 期望的类型  
log.debug("解析JWT成功，id={}，username={}", id, username);
```  
  
3. 然后，基于解析结果创建当事人对象：  
```java  
// 创建当事人对象，用于存入到Authentication对象中  
LoginPrincipal loginPrincipal = new LoginPrincipal();  
loginPrincipal.setId(id);  
loginPrincipal.setUsername(username);  
```  
  
4. 然后，将当事人对象用于创建认证信息对象：  
```java  
// 创建Authentication对象  
Object principal = loginPrincipal; // 当事人对象  
Object credentials = null;  
Authentication authentication = new UsernamePasswordAuthenticationToken(principal, credentials, authorities);  
```  
  
5. 后续，在控制器类中处理请求的方法中，当需要当事人数据时，注入`LoginPrincipal`类型的参数即可：  
```java  
public JsonResult<List<AdminListVO>> list(@ApiIgnore @AuthenticationPrincipal LoginPrincipal loginPrincipal) {
//                       ↑↑↑↑↑↑↑↑↑↑↑↑↑↑  自定义类型的当事人
```