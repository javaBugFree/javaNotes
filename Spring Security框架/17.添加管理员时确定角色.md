
添加管理员时，*必须为新管理员分配 至少1种角色*，否则，新添加的管理员将无法对应任何权限，在后台管理项目中，添加这样的管理员是没有意义的！

要实现添加管理员时分配角色，在【**服务器端**】需要：
1. 在*Mapper层*实现查询角色列表
    1. 创建 *RoleMapper*，并添加抽象方法
        ```java
        /**  
		 * 处理角色数据的Mapper接口  
		 */  
		@Repository  
		public interface RoleMapper {  
		  
		    /**  
		     * 查看角色列表  
		     *  
		     * @return 角色列表  
		     */  
		    List<RoleListItemVO> list();  
		  
		}
		```
    2. 创建 *RoleMapper.xml* ，配置以上抽象方法的SQL语句
        ```xml
        <!-- List<RoleListItemVO> list(); -->  
		<select id="list" resultMap="List">  
		    SELECT id, name, description, sort    
		    FROM ams_role    
		    ORDER BY sort DESC, id
		</select>  
		  
		<resultMap id="List" type="com.example.csmall.passport02.pojo.vo.RoleListItemVO">  
		    <id column="id" property="id"/>  
		    <result column="name" property="name"/>  
		    <result column="description" property="description"/>  
		    <result column="sort" property="sort"/>  
		</resultMap>
		```

2. *Service层*实现查询角色列表
    1. 创建 *RoleService* 接口，并添加抽象方法
        ```java
        /**  
		 * 处理角色的业务接口  
		 */  
		@Transactional  
		public interface RoleService {  
		  
		    /**  
		     * 查询角色列表  
		     *  
		     * @return 角色列表  
		     */  
		    List<RoleListItemVO> list();  
		  
		}
		```
    2. 创建实现类 *RoleServiceImpl*，实现以上方法
        ```java
        @Slf4j  
		@Service  
		public class RoleServiceImpl implements RoleService {  
		  
		    @Autowired  
		    RoleMapper roleMapper;  
		  
		  
		    @Override  
		    public List<RoleListItemVO> list() {  
		        List<RoleListItemVO> list = roleMapper.list();  
		  
		        // 获取迭代器对象  
		        Iterator<RoleListItemVO> iterator = list.iterator();  
		        // 移除1号元素  
		        while (iterator.hasNext()) {  
		            RoleListItemVO item = iterator.next();  
		            if (item.getId() == 1) {  
		                iterator.remove();  
		                break;  
		            }  
		        }  
		  
		        return list;  
		    }  
		}
		```
   
3. *Controller层*实现查询角色列表
    ```java
    @Slf4j  
	@RequestMapping("/roles")  
	@Api(tags = "角色管理模块")  
	@RestController  
	public class RoleController {  
	  
	    @Autowired  
	    private RoleService roleService;  
	  
	    @GetMapping("")  
	    @PreAuthorize("hasAuthority('/ams/admin/read')")  
	    @ApiOperation("查询角色列表")  
	    @ApiOperationSupport(order = 420)  
	    public JsonResult<List<RoleListItemVO>> list() {  
	        log.debug("开始处理【查询角色列表】的请求，参数：无");  
	        List<RoleListItemVO> list = roleService.list();  
	        return JsonResult.success(list);  
	    }  
	  
	}
	```
   
4. 在原有的*新增管理员的DTO*中添加新的属性，表示若干个角色（`Long[] roleIds`）
    ```java
    /**  
	 * 管理员的角色ID的数组  
	 */  
	@ApiModelProperty(value = "是否启用", required = false)  
	private Long[] roleIds;
	```

5. 在新增管理员的 *业务(Service)* 中，补充向 “管理员与角色的关联表” 中批量插入数据
    1. 创建Mapper接口 *AdminRoleMapper*，并添加*批量插入*抽象方法
        ```java
        /**  
		 * 处理角色数据的Mapper接口  
		 */  
		@Repository  
		public interface AdminRoleMapper {  
		  
		    /**  
		     * 批量插入数据  
		     *  
		     * @param adminRoleList 管理员与角色关联的实体类的集合  
		     * @return 受影响的行数  
		     */  
		    int insertBatch(List<AdminRole> adminRoleList);  
		  
		}
		```
    2. 创建 *AdminRoleMapper.xml* 文件，并配置以上方法的SQL语句
        ```xml
        <!-- int insertBatch(List<AdminRole> adminRoleList); -->  
		<insert id="insertBatch" useGeneratedKeys="true" keyProperty="id">  
		    INSERT INTO ams_admin_role(admin_id, role_id, gmt_create, gmt_modified)    
		    VALUES    
		    <foreach collection="list" item="adminRole" separator=",">  
		        (        
		        #{adminRole.adminId},#{adminRole.roleId},        
		        #{adminRole.gmtCreate},#{adminRole.gmtModified}        
		        )    
		    </foreach>  
		</insert>
		```
    3. 修改原有的 *AdminServiceImpl* 实现类中的 `addNew` 方法
        ```java
        @Override  
		public void addNew(AdminAddNewDTO adminAddNewDTO) {
			
			// 其他代码暂不关心
			
	        // 为新添加的管理员分配角色  
			// 通过参数得到角色ID的数组  
			Long[] roleIds = adminAddNewDTO.getRoleIds();  
			// 创建List<AdminRole>  
			List<AdminRole> adminRoleList = new ArrayList<>();  
			// 遍历角色id数组，并添加数据到集合中  
			for (Long roleId : roleIds) {  
			    AdminRole adminRole = new AdminRole();  
			    adminRole.setAdminId(admin.getId());  
			    adminRole.setRoleId(roleId);  
			    adminRoleList.add(adminRole);  
			}  
			// 调用AdminRoleMapper对象的insertBatch()执行插入  
			int i = adminRoleMapper.insertBatch(adminRoleList);  
			if (i < 1) {  
			    String message = "添加管理员失败，服务器忙，请稍后再尝试！";  
			    log.warn(message);  
			    throw new ServiceException(ServiceCode.ERR_INSERT, message);  
			}
		}
		```

6. 保障 *1号管理员* **有且仅有一个**，且**不允许查看**
    1. 再次修改原有的 *AdminServiceImpl* 实现类中的 `addNew` 方法
        ```java
        @Override  
		public void addNew(AdminAddNewDTO adminAddNewDTO) {
			
			// 通过参数得到角色ID的数组  
			Long[] roleIds = adminAddNewDTO.getRoleIds();  
			for (Long roleId : roleIds) {  
			    if (roleId == 1) {  
			        String message = "添加管理员失败，非法访问！";  
			        log.warn(message);  
			  
			        throw new ServiceException(ServiceCode.ERR_CONFLICT, message);  
			    }  
			}
			// 其他代码暂不关心
			
	        // 为新添加的管理员分配角色  
			// 创建List<AdminRole>  
			List<AdminRole> adminRoleList = new ArrayList<>();  
			// 遍历角色id数组，并添加数据到集合中  
			for (Long roleId : roleIds) {  
			    AdminRole adminRole = new AdminRole();  
			    adminRole.setAdminId(admin.getId());  
			    adminRole.setRoleId(roleId);  
			    adminRoleList.add(adminRole);  
			}  
			// 调用AdminRoleMapper对象的insertBatch()执行插入  
			int i = adminRoleMapper.insertBatch(adminRoleList);  
			if (i < 1) {  
			    String message = "添加管理员失败，服务器忙，请稍后再尝试！";  
			    log.warn(message);  
			    throw new ServiceException(ServiceCode.ERR_INSERT, message);  
			}
		}
		```
    2. 再修改该类的 `delete` 方法，保证1号数据不能被删除
        ```java
        @Override  
		public void delete(Long id) {  
		    log.debug("开始处理【根据id删除管理员】的业务，参数：{}", id);  
		  
		    // 检查尝试删除的是否为1号管理员  
		    if (id == 1) {  
		        String message = "删除管理员失败，尝试访问的数据不存在！";  
		        log.warn(message);  
		        throw new ServiceException(ServiceCode.ERR_NOT_FOUND, message);  
		    }
		    
			// 其他代码暂不关心  
		}
        ```
    3. 再修改该类的 `list` 方法，*使用迭代器*删除列表中的1号数据，干脆显示列表时就不让1号显示
        - *迭代器的作用*：遍历集合 *过程中* **安全地移除** 集合中的元素
        ```java
        @Override  
		public List<AdminListVO> list() {  
		    log.debug("开始处理【查询管理列表】的业务");  
		  
		    List<AdminListVO> list = adminMapper.list();  
		  
		    // 获取迭代器对象  
		    Iterator<AdminListVO> iterator = list.iterator();  
		    // 移除1号数据  
		    while (iterator.hasNext()) {  // 检查下一个元素是否存在  
		        // 获取下一个元素  
		        AdminListVO item = iterator.next();  
		        // 检查是否为1号元素，是则移除  
		        if (item.getId() == 1) {  
		            iterator.remove();  
		            break;  
		        }  
		    }  
		  
		    return list;  
		  
		}
        ```



【**客户端**】需要：
1. 添加多选框
```java
<!-- 多选框 -->  
<el-form-item label="角色">  
  <el-select v-model="ruleForm.roleIds" multiple placeholder="请选择">  
    <el-option  
        v-for="item in roleListOptions"  
        :key="item.id"  
        :label="item.name"  
        :value="item.id">  
    </el-option>  
  </el-select>  
</el-form-item>
```
2. 在data添加 角色列表的数组
```js
data() {  
  return {  
    roleListOptions: [],  // 角色列表的数组

    ruleForm: {
      username: 'test-admin-001',
      password: '123456',
      nickname: '测试管理员001',
      avatar: '12345',
      phone: '123456789',
      email: '123456789@163.com',
      description: '暂无',
      enable: 1,
      roleIds: []   // 若干个角色的id
    },
  };
}
```
3. 添加加载角色列表的方法
```js
// 加载角色列表  
  loadRoleList: function () {  
    let url = 'http://localhost:8091/roles';  
  
    this.axios  
        .create({'headers': {'Authorization': localStorage.getItem('jwt')}})  
        .get(url).then((response) => {  
      let responseBody = response.data;  
      this.roleListOptions = responseBody.data;  
    });  
  
  }  
},  
mounted() {  
  this.loadRoleList();  
}
```

4. 在服务器端的 *AdminServiceImpl* 的 `delete` 方法中 添加 *删除--管理员与角色的关联数据*
```java
// 执行删除--管理员与角色的关联数据  
log.debug("即将执行即将执行删除关联数据，参数：{}", id);  
int delete1 = adminRoleMapper.deleteByAdminId(id);  
if (delete1 < 1) {  
    String message = "删除管理员失败，服务器忙，请稍后再尝试！";  
    log.warn(message);  
    throw new ServiceException(ServiceCode.ERR_DELETE, message);  
}
```