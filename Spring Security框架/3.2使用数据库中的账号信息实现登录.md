
1. 首先，需要实现 “根据用户名查询用户信息” 的查询功能，需要执行的SQL语句大致是：
```sql
SELECT id, username, password, enable 
FROM ams_admin
WHERE username = ?
```

2. 在*pojo.vo包*下创建*AdminLoginInfoVO*类：  
```java  
/**  
 * 管理员的登录信息的VO类  
 */  
@Data  
public class AdminLoginInfoVO implements Serializable {  
  
    /**  
     * 数据id  
     */    
    private Long id;  
  
    /**  
     * 用户名  
     */  
    private String username;  
  
    /**  
     * 密码（密文）  
     */  
    private String password;  
  
    /**  
     * 是否启用  
     */  
    private Integer enable;  
  
}
```  
  
3. 在*AdminMapper.java*接口中添加抽象方法：  
```java  
AdminLoginInfoVO getLoginInfoByUsername(String username);  
```  
  
4. 在*AdminMapper.xml*中配置以上抽象方法映射的SQL语句：  
```xml
<!-- AdminLoginInfoVO getLoginInfoByUsername(String username); -->  
<select id="getLoginInfoByUsername" resultMap="LoginInfoResultMap">  
    SELECT id, username, password, enable    
    FROM ams_admin   
    WHERE username = #{username}
</select>  
  
<resultMap id="LoginInfoResultMap" type="com.example.csmall.passport02.pojo.vo.AdminLoginInfoVO">  
    <id column="id" property="id"/>  
    <result column="username" property="username"/>  
    <result column="password" property="password"/>  
    <result column="enable" property="enable"/>  
</resultMap>
```  
  
5. 在*AdminMapperTests*中编写并执行测试：  
```java
@Test  
void getLoginInfoByUsername() {  
  
    String username = "root";  
  
    AdminLoginInfoVO vo = adminMapper.getLoginInfoByUsername(username);  
    log.debug("{}", vo);  
  
}
```  

6. 然后，调整*UserDetailsServiceImpl*中的实现：  
```java  
@Slf4j  
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private AdminMapper adminMapper;  
  
    @Override  
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {  
  
        AdminLoginInfoVO loginInfo = adminMapper.getLoginInfoByUsername(s);  
        if (loginInfo == null) {  
            return null;  
        }  
  
        UserDetails userDetails = User.builder()  
                .username(loginInfo.getUsername())  
                .password(loginInfo.getPassword())     // 期望是 密文  
                // 这几个状态都可以选用  
                .disabled(loginInfo.getEnable() == 0)     // 账号状态，是否被禁用  
                .accountLocked(false)     // 账号状态，是否被锁定  
                .accountExpired(false)      // 账号状态，是否过期  
                .credentialsExpired(false)  // 账号状态，凭证是否过期  
                .authorities("这是一个临时使用的山寨权限")    // 权限  
                .build();  
  
        return userDetails;  
    }
```  
  
7. 由于数据库中的测试数据的密码都是密文的，例如：  
```  
$2a$10$N.ZOn9G6/YLFixAOPMg/h.z7pCu6v2XyFDtC4q.jeeGm/TEZyj15C  
```  
以上密文是通过BCrypt算法进行编码的结果！为了保证Spring Security能够正确的判断密码，需要将*密码编码器*改为**BCrypt的密码编码器**，例如：  
```java  
@Bean  
public PasswordEncoder passwordEncoder() {  
    // return NoOpPasswordEncoder.getInstance();    
    return new BCryptPasswordEncoder();
}  
```