
**SSO**（Single Sign On）：*单点登录*。表现为在集群或分布式系统中，客户端只需要 *在 某一个服务器上 登陆成功*，后续 *访问 其他服务器 都可以被识别身份*。

使用**JWT**来表示用户的身份信息，本身就是*支持单点登录*的。因此各 *服务器端* 只需要 **有共同的解析JWT的程序** 即可。

当在 *csmall-passport* 中完成认证与授权后，可以将*部分代码* **复制到** *csmall-product* 中，使得 *csmall-product* 中许多请求也是需要通过认证才允许访问的，并且进行访问权限的控制！
需要复制并修改的文件有：
- 复制依赖项：`Spring-boot-starter-security` 和 `jjwt` 和 `fastjson`
- 复制配置文件中的自定义属性：`csmall.jwt.secret-key` / `csmall.jwt.duration-in-minute`  
- 复制 *LoginPrincipal*  
- 复制 *ServiceCode*，覆盖 *csmall-product* 中原有的文件  
- 复制 *GlobalExceptionHandler*，覆盖 *csmall-product* 中原有的文件  
- 复制 *JwtAuthorizationFilter* 
- 复制 *Spring Security配置类*
  - 删除`PasswordEncoder`的`@Bean`方法  
  - 删除`AuthenticationManager`的`@Bean`方法  
  - 删除URL*白名单*中“管理员登录”的地址

实现原理：
3.10日，10：00整的视频有讲
3.14日，9：00有jwt安全问题


## 普通登录的问题

微服务架构下，要解决单点登录实现会话保持的问题。

首先我们分析以下 *普通登录* 和 *微服务登录* 的**区别**：

- 先是 **单体项目** 登录之后的操作流程，
主要 *依靠* **服务器的session** *保存用户信息*。
客户端发请求时，将*sessionid*同时发往服务器，根据sessionid就能确认用户身份
![[单体登录的流程.png]]

- **分布式或微服务项目**中，*服务器不再只有一个*  
那么就会出现下面的问题：
- session是在内存中的，一个服务器并不能访问另一个服务器的内存
![[分布式或微服务项目的问题.png]]

上面的图片，表示我们在微服务系统中登录时遇到的问题  

我们在用户模块中登录，只是将用户信息保存在用户模块的session中，
而 *这个session不会和其他模块共享*。
所以在我们访问购物车模块或其他模块时，**通过sessionid***并不能获得在用户模块中登录成功的信息*。
这样就丢失了用户信息，不能完成业务，会话保持就失败了。

市面上现在**大多使用JWT**来*实现微服务架构下的会话保持*。
也就是*在一个服务器上登录成功后，微服务的其他模块也能识别用户的登录信息*。

这个技术就是**单点登录**。

## 单点登录的解决方案

### *Session共享*

Session共享是能够实现单点登录效果的。

这种方式的 **核心思想** 是 *将用户的登录信息共享给其他模块*。

适用于 *小型的，用户量不大* 的微服务项目。

![[单点登录解决方案：Session共享.png]]

上面这个 *结构实现起来比较简单*，Spring有框架直接支持，添加配置和依赖即可实现单点登录。
  
这样就能 *将登录成功的用户信息* **共享给Redis**。
其他模块 **根据sessionId** 获得Redis中保存的用户信息即可。

**缺点！**
* 这样做最大的缺点就是 *内存严重冗余*，*不适合大量用户* 的微服务项目


### **JWT 单点登录**

Json Web Token(令牌)。
  
这种登录方式，**最大的优点** 就是 *不占用内存*。

![[单点登录解决方案：JWT.png]]

生成的JWT由 *客户端自己保存*，不占用服务器内存  
  
在需要表明自己用户身份/信息时，*将JWT信息* **保存到请求头中** *发送请求* 即可。

#### Jwt登录流程图

![[单点登录解决方案：JWT登录流程图.png]]