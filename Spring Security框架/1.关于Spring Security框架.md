
Spring Security主要解决了 **认证 与 授权** 相关的问题。
**认证：** 判断某个账号是否允许访问某个系统，简单来说，就是*验证登录*。
**授权：** 判断是否允许已经通过认证的账号访问某个资源，简单来说，就是*判断是否具有权限执行某项操作*。

难！！！建议多做几遍


## Spring Security框架的依赖项

在基于 Spring Boot 的项目中，使用 Spring Security 需要添加的依赖：
```xml
<!-- Spring Security 的依赖项，用于处理认证与授权相关的问题 -->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>
```


## Spring Security的典型特征

- 当在项目中添加以上依赖项后，你的项目会**发生以下变化**（Spring Boot 中的Spring Security 的*默认行为*），out of box ，开箱即用
    - *所有的请求*（包括原本404的） 都是*必须要登录 才允许访问的*，包括错误的URL（404都看不到）。
    - 提供了*默认*的登录页面，*当未登录时*，会*自动重定向* 到此登录页面。
    - 提供了*临时的登录账号*
        - 用户名是：user
        - 密码是启动项目时在*控制台中的 UUID值*（每次重启项目都会不同）
            - UUID值：*全球唯一* 编码。保证在同一时空中，值是唯一的。
        ![[UUID值.png]]
        - 登录时，如果在打开登录页面后重启过服务器端，应该刷新登录页面，否则，第1次输入并提交是无效的，因为有 防止伪造的跨域攻击 的防御机制存在，第一次生成的UUID值和第二次的不一致。
    
    - 当**登录成功后**，将 *自动重定向* 到 **此前尝试访问的页面**。如果此前没有尝试访问某个URL，则重定向到根路径（只有一个 "/"）。
    - 可以通过 **/logout** 路径访问到 *“退出登录”* 的页面，以实现**登出**。
        ![[logout.png]]
    
    - 当登录成功后，*默认* 不接受 普通的*POST请求*，而 *GET请求* 是*允许*的。
        - 因为存在 防止伪造的跨域攻击 的防御机制。
        ![[默认POST请求.png]]

