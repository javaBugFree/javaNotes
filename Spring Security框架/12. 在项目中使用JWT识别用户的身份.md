
## 核心流程

在项目中使用JWT识别用户的身份，大致需要：
- 当用户*通过登录的验证后*，*服务器*应该*生成JWT数据*，并*响应到客户端*。
    - 当通过验证后，将不再需要（没有必要）将用户的认证信息存入到 `SecurityContext` 中
- 当用户尝试执行需要通过认证的操作时，*用户应该 自主携带JWT*。并且，*服务器端*应该*尝试解析此JWT*，从而验证JWT的真伪，并识别用户的身份，如果一切无误，再将用户的认证信息存入到 `SecurityContext` 中。


## 1.登录成功后响应JWT

当用户通过登录的验证后，服务器应该生成JWT数据，并响应到客户端！
- JWT的加密算法格式叫*base64*

1. 当通过验证后，不再将用户的认证信息存入到`SecurityContext`中，则在`AdminServiceImpl`的`login()`方法中调整：  
```java  
// 使用JWT机制时，登录成功不再需要将认证信息存入到SecurityContext  
/*  
    // 将返回的认证信息保存到SecurityContext中  
    SecurityContext securityContext = SecurityContextHolder.getContext();    
    securityContext.setAuthentication(authenticateResult);
*/ 
```  
  
2. 在`AdminService`中，需要将`login()`方法的返回值类型改为`String`，表示登录成功后将返回JWT数据，例如：  
```java  
/**  
 * 使用前后端分离的登录  
 *  
 * @param adminLoginInfoDTO 封装了用户名、密码等相关信息的对象  
 * @return 此管理员登录后得到的JWT数据  
 */  
String login(AdminLoginInfoDTO adminLoginInfoDTO);
```  

并且，调整`AdminServiceImpl`中的`login()`的声明与实现：  
```java  
// 使用前后端分离的登录  
@Override  
public String login(AdminLoginInfoDTO adminLoginInfoDTO) {  
    log.debug("开始处理【管理员登录】的业务，参数：{}", adminLoginInfoDTO);  
  
    // 创建一个Authentication对象，用来作为authenticate()方法的参数  
    Authentication authentication = new UsernamePasswordAuthenticationToken(  
            adminLoginInfoDTO.getUsername(), adminLoginInfoDTO.getPassword()  
    );  
    // 调用authenticate()方法  
    // 注意：需要获取验证登录后的返回结果  
    Authentication authenticateResult = authenticationManager.authenticate(authentication);  
  
    log.debug("认证通过！（如果未通过，过程中将抛出异常，你不会看到此条日志！）");  
    log.debug("认证结果：{}", authenticateResult);  
    log.debug("认证结果中的当事人：{}", authenticateResult.getPrincipal());  
  
    // 使用JWT机制时，登录成功不再需要将认证信息存入到SecurityContext  
    /*        
    // 将返回的认证信息保存到SecurityContext中  
    SecurityContext securityContext = SecurityContextHolder.getContext();        
    securityContext.setAuthentication(authenticateResult);    
    */  
    
    // 需要存入到JWT中的数据  
    AdminDetails adminDetails = (AdminDetails) authenticateResult.getPrincipal();  
    Map<String, Object> claims = new HashMap<>();  
    claims.put("id", adminDetails.getId());  
    claims.put("username", adminDetails.getUsername());  
    // 权限待定  
  
    // 生成JWT，以下代码是相对固定的  
    String secretKey = "dayiuawyiawhidhawuyaiwh";  
    String jwt = Jwts.builder()  
            // Header：声明算法与Token类型。  
            .setHeaderParam("alg", "HS256")  
            .setHeaderParam("typ", "JWT")  
            // Payload部分，claims为数据  
            .setClaims(claims)  
            // // 过期时间,暂设为2分钟  
            .setExpiration(new Date(System.currentTimeMillis() + 2 * 60 * 1000))  
            // Verify Signature：验证签名  
            .signWith(SignatureAlgorithm.HS256, secretKey)  
            .compact();   // 将JWT打个包  
  
    log.debug("生成了JWT数据：{}", jwt);  
    return jwt;  
}
```  
  
3. 然后，还需要调整`AdminController`的`login()`方法，在调用Service的`login()`方法时获取返回的JWT，并响应到客户端，例如：  
```java  
// http://localhost:8091/admins/login  
@PostMapping("/login")  
public JsonResult<String> login(AdminLoginInfoDTO adminLoginInfoDTO) {  
    log.debug("开始处理【管理员登录】的请求，参数：{}", adminLoginInfoDTO);  
    // 登录并获取JWT数据  
    String jwt = adminService.login(adminLoginInfoDTO);  
    // 响应成功和JWT数据  
    return JsonResult.success(jwt);  
}
```


## 2. 解析客户端携带的JWT

客户端提交请求（无论是什么请求），都可能携带了JWT，在服务器端，处理多种不同的请求时都可能需要获取并尝试解析JWT，则应该使用 **过滤器**（`Filter`）组件进行处理！

>提示：过滤器（`Filter`）是*Java*服务器端应用程序的*核心组件之一*，它是 **最早** *接收到请求*的组件！过滤器可以选择对此请求进行 “*阻止*” 或 “*放行*”！同一个项目中，*允许存在若干个过滤器*，形成 "*过滤器链*"（FilterChain），任何一个请求，**仅当**过滤器上的每个过滤器*都*选择 ”*放行*“ 才可以被控制器或其他组件进行处理！

1. 在项目的根包下创建`filter.JwtAuthorizationFilter`类，继承自`OncePerRequestFilter`类，并在类上添加`@Component`注解，例如：  
```java  
/**  
 * <p>JWT过滤器</p>  
 * * <p>此过滤器的主要作用</p>  
 * <ul>  
 *     <li>接收客户端提交的请求中的JWT</li>  
 *     <li>尝试解析客户端提交的请求中的有效JWT</li>  
 *     <li>将解析成功得到的数据创建为Authentication对象，并存入到SecurityContext中</li>  
 * </ul>  
 */  
@Slf4j  
@Component  
public class JwtAuthorizationFilter extends OncePerRequestFilter {  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
          
    }  
}
```  
  
  
2. 然后，在过滤器的方法中接收JWT数据：  
```java  
@Slf4j  
@Component  
public class JwtAuthorizationFilter extends OncePerRequestFilter {  
  
    @Override  
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
	    log.debug("JWT过滤器开始执行……");  
	    // 根据业内惯用的做法，客户端提交的请求中的JWT应该存放于请求头（Request Header）中的名为Authorization属性中  
	    String jwt = request.getHeader("Authorization");  
	    log.debug("客户端携带的JWT：{}", jwt);  
	  
	    // 放行  
	    filterChain.doFilter(request, response);  
	} 
}  
```  


3. 然后，还需要在`SecurityConfiguration`中将此过滤器注册到Spring Security框架的过滤器链中：  
![[过滤器注册到过滤器链.png]]


4. 在API文档中，通过“全局参数设置”来配置请求头中的JWT数据：  
![[配置API文档的全局参数.png]]
  
**注意：** 在进行以上配置时，参数名称`Authorization`是严格区分大小写的，也不允许有多余的空格！  

5. 接下来，任何新打开的调试页面中都可以看到请求头中携带的数据：  
![[调试页面请求头部1.png]]
  
![[调试页面请求头部2.png]]

6. 判断客户端是否携带了有效的JWT，*是*则**尝试解析**，在过滤器的方法中进行修改
```java

/**  
 * <p>JWT过滤器</p>  
 * * <p>此过滤器的主要作用</p>  
 * <ul>  
 *     <li>接收客户端提交的请求中的JWT</li>  
 *     <li>尝试解析客户端提交的请求中的有效JWT</li>  
 *     <li>将解析成功得到的数据创建为Authentication对象，并存入到SecurityContext中</li>  
 * </ul>  
 */  
@Slf4j  
@Component  
public class JwtAuthorizationFilter extends OncePerRequestFilter {  
  
    // JWT的最小长度  
    public static final int JWT_MIN_LENGTH = 113;

	@Override  
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
	    log.debug("JWT过滤器开始执行...");  
	  
	    // 根据业内惯用的做法，客户端提交的请求中的JWT应该存放于请求头（Request Header）中的名为Authorization属性中  
	    String jwt = request.getHeader("Authorization");  
	    log.debug("客户端携带的JWT：{}", jwt);  
	  
	    // 判断客户端是否携带了有效的JWT  
	    // 字符串 不是null，并且不为空，而且不能是空白字符 或 jwt数据的长度小于其应有的最小长度  
	    if (!StringUtils.hasText(jwt) || jwt.length() < JWT_MIN_LENGTH){  
	        // 如果JWT无效，直接放行，交给之后的过滤器等组件处理
	        log.debug("客户端没有携带有效的JWT，将放行，由后续的过滤器等组件继续处理此请求...");  
	        filterChain.doFilter(request, response);  
	        return;  
	    }  
	
		// 如果JWT有效，尝试解析JWT  
		String secretKey = "dadjasdhasahiuawwkjawhfiawyuawakshdiawy";  
		Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();  
		  
		Object id = claims.get("id");  
		Object username = claims.get("username");  
		System.out.println("id = " + id);  
		System.out.println("username = " + username);  
		  
		// 临时处理认证信息中的权限  
		List<GrantedAuthority> authorities = new ArrayList<>();  
		authorities.add(new SimpleGrantedAuthority("这是一个山寨的权限！"));  
	  
		// 创建Authentication对象  
		Object principal = username;  
		Object credentials = null;  
		Authentication authentication = new UsernamePasswordAuthenticationToken(principal, credentials, authorities);
		  
		// 将Authentication对象存入到SecurityContext中  
		SecurityContext securityContext = SecurityContextHolder.getContext();  
		securityContext.setAuthentication(authentication);
	  
	    // 放行  
	    filterChain.doFilter(request, response);  
	}
}
```
