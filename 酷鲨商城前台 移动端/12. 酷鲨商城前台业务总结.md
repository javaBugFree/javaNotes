
## "我负责的功能"  
  
登录（SSO），注册；

显示商品分类（自关联三级分类树）；

显示商品列表；

显示商品详情；

购物车管理（显示购物车列表，添加购物车，删除购物车，修改购物车数量）；

生成订单（减少库存，删除购物车，新增订单，新增订单项，修改订单状态等，查询订单列表）；

搜索商品（使用ES完成根据关键字进行全文搜索）；

商品秒杀功能（缓存预热库存 / 随机码 / 布隆过滤器，检查重复购买和防止超卖，生成订单，消息队列,流控）。


## 项目的模块和我负责的模块  

分类信息模块和商品显示模块(front)
购物车和订单(order)
搜索模块(search)
秒杀模块(seckill)
单点登录SSO(passport)


没做的模块(不建议写):
支付模块,
物流模块,
客服模块,
评论模块


## 三级分类树  

本项目使用*固定的三级分类树*（因为京东等电商网站的也是三级分类树，所以经过我们讨论，也定为三级分类树）

是*自关联分类*（所有分类信息在一张表中）

实现思路  
  
1.一次性查询出所有分类对象(List集合)  
  
2.遍历集合将当前分类对象以父分类id为Key,以当前对象作为值,保存在一个Map中,这个Map对象的Key(父级分类ID)对应的value,会包含它的所有子分类对象  
  
3.遍历所有分类对象,以当前分类对象id为key,从Map中获取它的子分类,关联到三级分类树对象中,最后返回包含三级分类树结构的集合  
  
4.查询返回之前,将三级分类树保存到Redis,以便以后的请求高效获取  
  
## 如何实现spu列表  
  
可能是通过分类id查询出spu列表  
  
也可能是ES搜索功能搜索出的spu列表  
  
显示它们的注意事项就是分页(JsonPage)  
  
分类id查询数据库,分页是PageHelper  
  
搜索查询是ES,分页SpringData  
  
## 如何显示一个商品的详情  
  
商品详情页面有4个查询  
  
1.SpuId查询spu表中信息显示的内容有默认价格\title\name\默认图片等  
  
2.SpuId查询spu_detail表中信息,内容是商品详情大图片  
  
3.根据SpuId查询商品的所有属性  
  
 是先用spuid关联到分类id,再由分类id关联到属性id,在获得属性id包含的所有属性,是一个关联查询  
  
 如果是一个智能手机分类下的spu,能够查询到例如内存\处理器\颜色等规格属性  
  
4.根据spuId查询Sku列表  
  
 只有查询到Sku列表,才知道具体的真实价格\图片\库存的情况  
  
 当选择对应规格属性时,才能知道有货无货  
  
## 如何实现购物车的管理  
  
用户在商品详情页选择属性之后,能够确定sku  
  
将用户选中的sku保存在购物车中,  
  
需要用户登录,因为所有购物车操作都需要用户身份  
  
在控制器方法前添加@PreAuthorize("hasRole('user')") SpringSecurity单点登录  
  
在业务逻辑层方法中,可以从SpringSecurity上下文中获取用户信息  
  
我们新增到购物车中的商品要检查是否已经在购物车中,如果不在新增到购物车,如果在的话,修改数量即可  
  
删除或清空购物车功能就是按照购物车id进行操作即可  
  
修改购物车中商品数量时,可以判断一下库存是否允许,如果没有库存就修改失败  
  
## 生成订单功能如何实现  
  
用户选好了商品,或勾选了购物车中购买的商品  
  
就可以进行订单的生成了,在用户已经登录的前提下  
  
首先减少库存数,如果用户从购物车勾选,删除用户勾选购物车的商品  
  
然后开始收集各种数据,使用Leaf生成唯一的id,  
  
确定单价和购买的数量,生成订单对象同时也生成订单项对象  
  
一个订单中可能包含多个商品,计算总价,包含运费和优惠的处理  
  
所有数据收集完毕之后,新增到数据库  
  
我们利用Dubbo去修改sku库存信息,其他修改都是本模块的功能  
  
任何数据库操作失败都要抛出发生异常  
  
我们可以利用分布式事务seata来根据运行状态决定最终要提交还是回滚  
  
保证订单生成之后数据的完整性  
  
## 搜索功能如何实现  
  
我们使用Elasticsearch全文搜索引擎实现搜索功能  
  
先创建\配置关联Es的实体类  
  
我们可以使用logstash实现数据库和Es信息的同步  
  
(也可以编写代码分页查询所有表中信息在分批增到ES中,只是后续同步数据比较麻烦)  
  
搜索功能本身使用SpringDataElasticsearch实现  
  
将用户输入的关键字获取到Es中进行分页查询  
  
将查询到的Spu列表返回给前端即可  
  
## 如何实现秒杀  
  
对于秒杀业务,我们首先要考虑的是怎么能够在有限的设备上达到最高的并发  
  
因为秒杀是典型的高并发高性能的业务需求  
  
所以我们要尽可能的使用能够提升性能和并发的组件或功能  
  
同时保证服务器的稳定运行  
  
例如:Redis,ES,Sentinel,消息队列等  
  
具体实现秒杀分为几个步骤  
  
### 秒杀前准备  
  
我们可以利用任务调度工具Quartz在指定的时间进行缓存预热准备工作  
  
主要两方面  
  
1.在秒杀开始前指定的时间,Redis缓存预热,将每个sku参与秒杀的库存数保存在Redis中  
  
 而且为了避免黄牛通过技术手段频繁访问,可以生成一个随机码,也保存在Redis中,用于验证是否为正常链接购买秒杀商品  
  
2.在每个批次秒杀开始前,将本批次所有秒杀商品的spuid保存在布隆过滤器中,减少缓存穿透的情况  
  
### 秒杀信息的查询  
  
秒杀开始,用户在秒杀商品的规定时间内可以查询秒杀商品详情  
  
所有秒杀商品spu查询时,都先查询布隆过滤器是否包含这个spuId,如果包含允许访问,如果不包含抛出异常,也要考虑布隆过滤器误判的情况,  
  
每当业务中查询spu和sku时,都需要先检查redis中是否包含这个数据,如果包含直接从redis中获得,如果不包含再从数据库中查,但是同时也注意,查询完了要保存到Redis中,以便之后的查询直接从redis中获取,在保存到Redis时,为了减少缓存雪崩的几率,我们为每个Spu和Sku对象都添加了过期时间随机数  
  
查询返回前,可以在判断一下当前时间是否在可秒杀该商品的时间段内,如果不在秒杀时间段内,抛出异常  
  
只有返回了完整信息,前端才可能获得包含随机码的提交路径,否则是无法完成正常连接购买的  
  
### 提交秒杀信息  
  
在用户购买秒杀商品时,保证用户登录的前提下  
  
验证用户是否重复秒杀(业务要求秒杀相同商品只能购买一次),我们使用userId和skuId,向Redis中保存一个key,如果没有这个key就是用户没有秒杀过,否则发生异常提示  
  
我们要保证用户购买时,这个商品有库存,从Redis预热的库存数中获取,减少库存后,获得剩余库存信息  
  
只要剩余库存不小于0,就可以为当前用户生成订单,否则发生异常  
  
生成订单直接Dubbo调用Order模块编写的生成订单的方法即可  
  
订单提交后,还需要修改秒杀sku库存数和生成秒杀成功记录保存在数据库  
  
但是这个业务非迫切运行,我们可以将信息发送给消息队列,削峰填谷  
  
然后再编写接收消息队列的代码,完成修改秒杀库存和生成秒杀成功记录的操作  
  
在控制层方法上添加注解实现Sentinel的限流,保证这个业务在非常大的并发下,也能稳定运行  
  
控制器方法中还要判断用户请求路径中的随机码,是否和Redis中保存的随机码一致,防止非正常链接购买