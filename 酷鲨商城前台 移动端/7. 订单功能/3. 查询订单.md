
在新增订单成功之后，用户会看到订单列表。

可以 *按时间* **查询一段时间范围内** 的订单列表，
  
我们 *默认查询* 当前时间 *一个月以内* 的所有订单信息。
  
订单信息要包括 *oms_order和oms_order_item* 两个表的信息  
  
所以是一个 *连表查询*
  
**关联查询语句示例**：
```sql
SELECT 
	oo.id,
	oo.sn,
	oo.user_id,
	oo.contact_name,
	oo.state,
	oo.amount_of_actual_pay,
	oo.gmt_order,
	oo.gmt_pay,
	oo.gmt_create,
	oo.gmt_modified,
	ooi.id ooi_id,
	ooi.order_id,
	ooi.sku_id,
	ooi.title,
	ooi.price,
	ooi.quantity
FROM oms_order oo
	JOIN oms_order_item ooi ON ooi.order_id = oo.id
WHERE	oo.user_id = 1
	AND	oo.gmt_create > '2023-3-1'
	AND	oo.gmt_create < NOW()
ORDER BY oo.gmt_modified DESC
```


## 开发持久层

1. *OmsOrderMapper*：
```java
/**  
 * 查询当前登录用户指定时间范围内所有订单信息  
 *  
 * @param orderListTimeDTO 偷个懒，主要是利用该类里面的三个属性  
 * @return 订单信息的集合  
 */  
List<OrderListVO> selectOrdersBetweenTimes(OrderListTimeDTO orderListTimeDTO);
```

2. *OmsOrderMapper.xml*：

- **collection** *标签*：
    - OrderListVO 类型中包含订单项的集合，需要编写*特殊映射关系*才能顺利查询。
    - 使用 *collection标签* 来映射 *对象中的集合属性*
    - **标签属性：**
        - `property`（**必填**）：指定 *要映射的* **属性名称**。
        - `javaType`（*可选*）：指定 **集合的类型**，*默认*类型为*List*，如果匹配就*可以省略*。
            - *数组*的话就用：`javaType="java.util.Arrays"`
        - `ofType`（**必填**）：指定 **集合的泛型类型**，泛型类型就是被赋值的对象。

```xml
<!-- 重要！ -->  
<!-- 查询当前登录用户指定时间范围内所有订单信息 的 resultMap -->
<resultMap id="OrderWithOrderItemMap" type="cn.tedu.mall.pojo.order.vo.OrderListVO">  
    <id column="id" property="id"/>  
    <result column="sn" property="sn"/>  
    <result column="user_id" property="userId"/>  
    <result column="contact_name" property="contactName"/>  
    <result column="state" property="state"/>  
    <result column="amount_of_actual_pay" property="amountOfActualPay"/>  
    <result column="gmt_order" property="gmtOrder"/>  
    <result column="gmt_pay" property="gmtPay"/>  
    <result column="gmt_create" property="gmtCreate"/>  
    <result column="gmt_modified" property="gmtModified"/>  
      
    <!--OrderListVO 类型中包含订单项的集合，需要编写特殊映射关系才能顺利查询-->
    <!-- 使用collection标签来映射 对象中的集合属性 -->  
    <!--
	    标签属性：  
        property(必填)：指定要映射的属性名称
        javaType(可选)：指定集合的类型，默认类型为List，如果匹配就可以省略。
            数组的话就用：javaType="java.util.Arrays"
        ofType(必填)：指定集合的泛型类型，泛型类型就是被赋值的对象
    -->  
    <collection property="orderItems"   
javaType="java.util.Arrays"  
                ofType="cn.tedu.mall.pojo.order.vo.OrderItemListVO">  
        <id column="ooi_id" property="id"/>  
        <result column="order_id" property="orderId"/>  
        <result column="sku_id" property="skuId"/>  
        <result column="title" property="title"/>  
        <result column="price" property="price"/>  
        <result column="quantity" property="quantity"/>  
    </collection>  
</resultMap>


<!-- 查询当前登录用户指定时间范围内所有订单信息 -->  
<!-- List<OrderListVO> selectOrdersBetweenTimes(OrderListTimeDTO orderListTimeDTO); -->  
<select id="selectOrdersBetweenTimes" resultMap="OrderWithOrderItemMap">  
    SELECT oo.id,           
		   oo.sn,           
		   oo.user_id,           
		   oo.contact_name,           
		   oo.state,           
		   oo.amount_of_actual_pay,           
		   oo.gmt_order,           
		   oo.gmt_pay,           
		   oo.gmt_create,           
		   oo.gmt_modified,           
		   ooi.id ooi_id,           
		   ooi.order_id,           
		   ooi.sku_id,           
		   ooi.title,           
		   ooi.price,           
		   ooi.quantity    
    FROM oms_order oo             
	    JOIN oms_order_item ooi ON ooi.order_id = oo.id    
    WHERE oo.user_id = #{userId}      
	  AND oo.gmt_create &gt; #{startTime}  
      AND oo.gmt_create &lt; #{endTime}  
    ORDER BY oo.gmt_modified DESC
</select>
```



## 开发业务逻辑层

*OmsOrderServiceImpl* 实现类实现方法：
```java
// 分页查询指定时间区间，当前登录用户的所有订单信息  
@Override  
public JsonPage<OrderListVO> listOrdersBetweenTimes(OrderListTimeDTO orderListTimeDTO) {  
  
    // 方法开始，需要在运行查询前先判断用户给定的时间范围  
    /*  
        要判断orderListTimeDTO参数中的开始时间和结束时间，默认一个月内  
        编写一个方法专门进行判断  
     */    
    validateTime(orderListTimeDTO);  
  
    // 设置分页查询条件  
    PageHelper.startPage(orderListTimeDTO.getPage(), orderListTimeDTO.getPageSize());  
  
    // 给当前登录用户id赋值  
    orderListTimeDTO.setUserId(GetUserInfo.getUserId());  
  
    // 下面执行查询  
    List<OrderListVO> list = orderMapper.selectOrdersBetweenTimes(orderListTimeDTO);  
  
    // 返回  
    return JsonPage.restPage(new PageInfo<>(list));  
}  
  
// 判断查询订单业务中的开始时间和结束时间  
private void validateTime(OrderListTimeDTO orderListTimeDTO) {  
  
    // 先获取开始时间和结束时间对象  
    LocalDateTime startTime = orderListTimeDTO.getStartTime();  
    LocalDateTime endTime = orderListTimeDTO.getEndTime();  
    // 判断start和end是否为null  
    /*        
	    有四种情况：  
        都null：默认当前时间前一个月  
        都不null：按照用户给定的  
        开始时间为null：自行设计，可以把 给定结束时间 前面时间的都查了，也可以只查结束时间之前一个月。  
        结束时间为null：自行设计，可以把 给定开始时间 之后的都查了，也可以只查开始时间之后一个月。  
     */    
    // 这里是只要有任何一个属性为null，查询最近一个月订单  
    if (startTime == null || endTime == null) {  
        // 开始时间设置为一个月之前  
        // 以下为 当前时间减一个月  
        LocalDateTime start = LocalDateTime.now().minusMonths(1);  
        LocalDateTime end = LocalDateTime.now();  
        /*  
            以下为 当前时间加一个月  
            LocalDateTime.now().plusMonths(1);         
        */  
        // 将设置好的之赋值到参数对象进行汇总  
        orderListTimeDTO.setStartTime(start);  
        orderListTimeDTO.setEndTime(end);  
    } else {  
        /*  
            如果start和end都非空。  
            要判断end是否小于start，  
            如果小于：可以抛出异常、或着帮它反过来  
            if(end.isBefore(start))
         */        
         /*            
	        国际化：  
            如果是需要判断时区时间，则都转换为格林威治时间，再做比较  
         */        
        if (endTime.toInstant(ZoneOffset.of("+8")).toEpochMilli()  
                < startTime.toInstant(ZoneOffset.of("+8")).toEpochMilli()) {  
            // 结束时间小于开始时间  
            throw new CoolSharkServiceException(ResponseCode.BAD_REQUEST, "结束时间应大于开始时间");  
        }  
    }  
}
```


## 开发控制层

*OmsOrderController*添加方法

```java
@GetMapping("/list")  
@ApiOperation("分页查询当前用户指定时间内订单信息")  
@PreAuthorize("hasAuthority('ROLE_user')")  
public JsonResult<JsonPage<OrderListVO>> listUserOrders(OrderListTimeDTO orderListTimeDTO) {  
    JsonPage<OrderListVO> jsonPage = omsOrderService.listOrdersBetweenTimes(orderListTimeDTO);  
  
    return JsonResult.ok(jsonPage);  
}
```


## 测试

启动 Nacos / Seata  
  
如果没有登录的话启动sso(passport)做jwt复制
  
如果有可用的jwt
直接启动order即可  测试端口 10005  
  
**订单的新增和订单的查询一定要多练习几次**  
**面试时一定要会讲述业务流程**