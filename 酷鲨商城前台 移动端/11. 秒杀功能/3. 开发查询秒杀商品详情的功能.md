
之前我们完成了缓存预热  
  
下面要 *根据SpuId* 查询 *正在秒杀的商品*
  
和普通的SpuId查询商品详情相比，
它的业务判断更复杂：
1. 页面上显示秒杀价和剩余秒杀时间等信息。
2. 判断请求的spuId是否在布隆过滤器中（后续完成）。
3. 判断Redis 中是否包含商品信息。
4. 如果一切正常在返回详情信息前，要为url属性赋值，其实就是固定路径+随机码。


## 根据SpuId查询秒杀商品详情

### 开发业务逻辑层

之前的章节已经完成了根据SpuId查询Spu信息的mapper

下面我们直接从业务逻辑层开始编写即可

*SeckillSpuServiceImpl* 业务逻辑层实现类
```java
// 装配操作Redis的对象  
@Autowired  
private RedisTemplate redisTemplate;

// 根据spuId查询到既包含常规信息又包含秒杀信息的SeckillSpuVO  
@Override  
public SeckillSpuVO getSeckillSpu(Long spuId) {  
    /*  
        1. 完整代码中，这里应该先从Redis中获取布隆过滤器  
        使用布隆过滤器判断参数spuId是否在数据库中存在，如果不存在直接抛出异常  
     */  
    /*
	    2. 当前业务要返回SeckillSpuVO，是要保存到Redis中的  
        还要补充秒杀信息和常规信息  
     */
    // 先获取这个对象的key  
    // spuVOKey:mall:seckill:spu:vo:2    
    String spuVOKey = SeckillCacheUtils.getSeckillSpuVOKey(spuId);  
  
    // 声明SeckillSpuVO返回值类型的对象，方便后续操作  
    SeckillSpuVO seckillSpuVO;  
  
    // 判断Redis中是否包含这个对象的key  
    if (redisTemplate.hasKey(spuVOKey)) {  
        // 如果包含，直接从Redis中获取这个对象，方便下面操作  
        seckillSpuVO = (SeckillSpuVO) redisTemplate.boundValueOps(spuVOKey).get();  
    } else {  
        /*  
            如果Redis中没有这个Key，要从数据库中查询  
            要查询秒杀信息和常规信息，最后都赋值到SeckillSpuVO对象中。  
         */        
        // 1.先查秒杀信息  
        SeckillSpu seckillSpu = seckillSpuMapper.findSeckillSpuById(spuId);  
        // 判断一下这个seckillSpu是否为null（因为布隆过滤器可能会误判(万分之一到千分之一的概率)）  
        if (seckillSpu == null) {  
            throw new CoolSharkServiceException(ResponseCode.NOT_FOUND, "您要访问的商品不存在");  
        }  
        // 2.查询spu常规信息  
        SpuStandardVO standardVO = dubboSeckillSpuService.getSpuById(spuId);  
        // 将常规信息和秒杀信息都赋值到seckillSpuVO对象中  
        seckillSpuVO = new SeckillSpuVO();  
        BeanUtils.copyProperties(standardVO, seckillSpuVO);  
        // 赋值秒杀信息  
        seckillSpuVO.setSeckillListPrice(seckillSpu.getListPrice());  
        seckillSpuVO.setStartTime(seckillSpu.getStartTime());  
        seckillSpuVO.setEndTime(seckillSpu.getEndTime());  
  
        // 3.将seckillSpuVO对象保存到Redis中，方便后面的请求从Redis中获取  
        redisTemplate.boundValueOps(spuVOKey).set(  
                seckillSpuVO,  
                1000 * 60 * 5 + RandomUtils.nextInt(10000),  
                TimeUnit.MILLISECONDS);  
    }  
    // 到此为止，seckillSpuVO对象只有 url属性 没有赋值了  
  
    /*  
        url是否有值，直接影响前端页面是否能够 提交订单
        （没有值的话前端的 提交按钮 处应该显示 秒杀未开始）
        给url赋值的条件是：当前时间是否允许购买当前商品  
     */    
    // 获取当前时间  
    LocalDateTime nowTime = LocalDateTime.now();  
      
    /*  
        判断时，使用Java代码，尽量不连接数据库，节省系统资源  
        判断逻辑是 当前时间 > 秒杀开始时间 并且 当前时间 < 秒杀结束时间  
     */    
    if (seckillSpuVO.getStartTime().isBefore(nowTime) &&  
            seckillSpuVO.getEndTime().isAfter(nowTime)) {  
        // 进入当前if表示现在允许秒杀购买本spu商品，要为url赋值  
        // 我们要从Redis中获取已经预热的随机码  
  
        // 获取Key  
        String randCodeKey = SeckillCacheUtils.getRandCodeKey(spuId);  
        // 判断Redis中有没有这个Key，真空那个时间段  
        if (!redisTemplate.hasKey(randCodeKey)) {  
            // 如果没有，异常提示随机码不存在  
            throw new CoolSharkServiceException(ResponseCode.INTERNAL_SERVER_ERROR, "随机码不存在(等到下一分钟再试)");  
        }  
        // key正常，从Redis中获取  
        int randCode = (int) redisTemplate.boundValueOps(randCodeKey).get();  
        // 随机码赋值到url属性中  
        seckillSpuVO.setUrl("/seckill/" + randCode);  
        log.info("商品详情对象构建完成，url属性为：{}", seckillSpuVO.getUrl());  
    }  
  
    // 最后别忘了把seckillSpuVO返回  
    return seckillSpuVO;  
}
```


### 开发控制层

*SeckillSpuController*
```java
// http://localhost:10007/seckill/spu/2  
@GetMapping("/{spuId}")  
@ApiOperation("根据spuId查询spu相关信息")  
@ApiImplicitParam(name = "spuId", value = "spuId", example = "2")  
public JsonResult<SeckillSpuVO> getSeckillSpuVo(@PathVariable Long spuId) {  
    SeckillSpuVO seckillSpuVO = seckillSpuService.getSeckillSpu(spuId);  
    return JsonResult.ok(seckillSpuVO);  
}
```


### 测试

保持 Nacos/Redis / Seata启动  
  
启动product模块  
重启Seckill模块  
  
测试10007端口功能  
  
注意要 **加载随机码信息(预热)之后** 再进行访问