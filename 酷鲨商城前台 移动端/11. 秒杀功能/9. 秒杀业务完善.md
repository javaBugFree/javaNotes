
## 秒杀准备时加载布隆过滤器

我们在开发秒杀业务时，事先进行了准备工作：
在秒杀 *开始前5分钟*，**预热了** *sku的库存数 和 spu的随机码*。

*但是没有* 将当前批次的spuId保存在布隆过滤器中，
导致业务有漏洞（缓存穿透）。
  
现在，我们准备了支持布隆过滤器的Redis，
我们可以将 *允许用户查询到的秒杀商品*，*保存到布隆过滤器* 中，
这样非当前秒杀商品，用户就不能查询数据库了，防止缓存穿透。

布隆过滤器要想使用，需要 **先经历 生成 阶段**，**再经历 判断 阶段**。
  
我们对布隆过滤器的 **生成** 也是 **预热** 性质的，在秒杀开始之前编写Quartz框架的Job实现类。
  
在seckill-webapi模块中，
seckill.timer.job包中，新建*SeckillBloomInitialJob*：
```java
/**  
 * 布隆过滤器 预热  
 */  
@Slf4j  
public class SeckillBloomInitialJob implements Job {  
  
    // 装配操作布隆过滤器的类  
    @Autowired  
    private RedisBloomUtils redisBloomUtils;  
    // 装配能查询数据库中所有秒杀spu的id的mapper  
    @Autowired  
    private SeckillSpuMapper seckillSpuMapper;  
  
    @Override  
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {  
  
        /*  
            这个方法要求将秒杀商品包中的spuId保存到布隆过滤器中  
            在秒杀时减少缓存穿透，提升服务器运行效率            
            为布隆过滤器生成的Key可以和日期关联，如果每天只有一次秒杀，直接使用日期即可  
         */        
        // spu:bloom:filter:2023-4-12        
	    String bloomDateKey = SeckillCacheUtils.getBloomFilterKey(LocalDate.now());  
  
        // 查询数据库中所有spuId  
        Long[] spuIds = seckillSpuMapper.findAllSeckillSpuIds();  
  
        /*  
            从数据库查询出的数组类型是Long[]，但是布隆过滤器只支持String[]  
            所以我们要进行一个转换，将Long类型数组的的元素转换为String类型  
         */        
        String[] spuIdsStr = new String[spuIds.length];  
  
        // 对spuIds进行遍历，元素转换后赋值到spuIdsStr中  
        for (int i = 0; i < spuIds.length; i++) {  
            spuIdsStr[0] = spuIds[0] + "";  
        }  
  
        // 获取了包含所有spuId的String数组，将它保存到布隆过滤器中  
        redisBloomUtils.bfmadd(bloomDateKey, spuIdsStr);  
        log.info("布隆过滤器加载数据完成！");  
    }  
}
```


下面在seckill.timer.config包中添加布隆过滤器相关的 *调度配置*,
继续在 *QuartzConfig类* 中 **添加绑定信息**：
```java
// 向Spring容器中保存JobDetail对象  
@Bean  
public JobDetail BloomInitJobDetail() {  
    return JobBuilder.newJob(SeckillBloomInitialJob.class)  
            .withIdentity("BloomInitJobDetail")  
            .storeDurably()  
            .build();  
}  
  
// 向Spring容器中保存Trigger对象进行触发  
@Bean  
public Trigger BloomInitTrigger() {  
    // 12:00  14:00  16:00  18:00  进行秒杀，提前五分钟的cron表达式  
    // 0 55 11,13,15,17 * * ?  
    // 学习过程中，为了测试观察效果，我们设计每分钟运行一次  
    CronScheduleBuilder cron = CronScheduleBuilder.cronSchedule("0 0/1 * * * ?");  
  
    return TriggerBuilder.newTrigger()  
            .withIdentity("BloomInitTrigger")  
            .forJob(BloomInitJobDetail())  
            .withSchedule(cron)  
            .build();  
}
```


下面可以测试布隆过滤器的运行  

保证虚拟机启动正常，

启动 product / seckill  
  
如果没有虚拟机的同学，敲一遍代码熟悉即可。


## 布隆过滤器判断spuId是否存在

现在Redis中保存了布隆过滤器，
  
我们需要用户根据SpuId查询商品时，进行判断和过滤。

**如果spuId不存在，就应该发生异常，给出提示。**
  
*SeckillSpuServiceImpl 类* 中 *getSeckillSpu 方法* 进行修改，添加布隆过滤器的判断：
```java
// 装配操作布隆过滤器的对象  
@Autowired  
private RedisBloomUtils redisBloomUtils;  
  
// 根据spuId查询到既包含常规信息又包含秒杀信息的SeckillSpuVO  
@Override  
public SeckillSpuVO getSeckillSpu(Long spuId) {  
    /*  
        1. 这里应该先从Redis中获取布隆过滤器  
        使用布隆过滤器判断参数spuId是否在数据库中存在，如果不存在直接抛出异常  
     */    
    // 获取布隆过滤器的key  
    String bloomDateKey = SeckillCacheUtils.getBloomFilterKey(LocalDate.now());  
    // 判断这个key是否存在  
    if (!redisTemplate.hasKey(bloomDateKey)) {  
        // 不存在，说明布隆过滤器未创建  
        String message = "布隆过滤器未创建";  
        log.warn(message);  
        throw new CoolSharkServiceException(ResponseCode.INTERNAL_SERVER_ERROR, message);  
    }  
    // 使用布隆过滤器判断参数spuId是否在数据库中存在，如果不存在直接抛出异常  
    if (!redisBloomUtils.bfexists(bloomDateKey, spuId + "")) {  
        // 不存在，说明当前spuId不在布隆过滤器中，布隆过滤器生效，防止了缓存穿透  
        String message = "您访问的商品不存在(布隆过滤器生效)";  
        log.warn(message);  
        throw new CoolSharkServiceException(ResponseCode.NOT_FOUND, message);  
    }
	
	// 后续代码略
}
```

重启Seckill模块  
  
访问10007  
  
查询SpuId如果不存在于秒杀表中，是否能被过滤器拦截。