
## 创建 流控和降级 的处理类

秒杀业务肯定是一个 **高并发** 的处理，*并发数超过程序设计的限制时*，就需要对请求的数量进行限流。

Sentinel是阿里提供的SpringCloud组件，主要用于外界访问当前服务器的控制器方法的限流操作。
之前的课程中，我们已经比较详细的学习的Sentinel使用的方式。

下面我们要先编写Sentinel限流和服务降级时，运行的自定义异常处理类。

我们酷鲨前台项目 *seckill-webapi模块*


1. 先来编写 **限流异常处理类**
    - 当 限流/降级 方法 **编写的位置** *和控制器不同* 时，那么 限流/降级 方法**要声明static**。
    - 创建一个*exception包*，包中新建 *SeckillBlockHandler*， 代码如下：
```java
/**  
 * 秒杀业务限流异常处理类  
 */  
@Slf4j  
public class SeckillBlockHandler {  
  
    /*  
        声明限流的方法，返回值和参数大多和被限流的控制器方法一致  
        只是参数末尾要添加一个BlockException的参数  
        当 限流/降级 方法编写的位置和控制器不同时，那么 限流/降级 方法要声明static  
     */    
    public static JsonResult seckillBlock(String randCode,  
                                          SeckillOrderAddDTO seckillOrderAddDTO,  
                                          BlockException e) {  
        log.error("限流了一个请求!");  
        return JsonResult.failed(  
                ResponseCode.INTERNAL_SERVER_ERROR, "服务器忙,请稍后再试");  
    }  
  
}
```

2. 再创建降级类 *SeckillFallback*
    - 降级处理方法基本和限流一致，只是*参数修改为Throwable*。
```java
/**  
 * 秒杀业务的降级处理类  
 */  
@Slf4j  
public class SeckillFallback {  
  
    // 降级处理方法基本和限流一致，只是参数修改为Throwable
    public static JsonResult seckillFallback(String randCode,  
                                             SeckillOrderAddDTO seckillOrderAddDTO,  
                                             Throwable throwable){  
        log.error("某个请求因为发生异常降级了！");  
        throwable.printStackTrace();  
        return JsonResult.failed(ResponseCode.INTERNAL_SERVER_ERROR,  
                "发生异常，错误信息为：" + throwable.getMessage());  
    }  
  
}
```



## 开发执行秒杀的业务逻辑层

我们之前完成了*秒杀的预热*，预热中完成了秒杀商品sku库存数，spu随机码(布隆过滤器)保存在redis中的操作。
也完成了*查询秒杀商品列表*，和 *显示秒杀商品详情* 的方法。
  
下面要开始进行 **秒杀商品生成订单** 的操作。
  
如果用户选择商品规格(sku)提交订单，那么就要按照提交秒杀订单的业务流程处理。
  
秒杀提交订单和普通订单的 **区别**：
1. 使用Redis判断 *用户是否为重复购买* 和 *该Sku是否有库存*。
2. *秒杀订单 转换 成普通订单*，需要使用dubbo调用order模块的生成订单方法。
3. **使用消息队列(RabbitMQ)** 将 *秒杀成功记录信息* 保存到success表中
4. *秒杀订单信息返回*。


### 业务逻辑层总流程

创建一个*SeckillServiceImpl*业务逻辑层实现类，完成上面的业务：
```java
/**  
 * 秒杀业务  
 */  
@Slf4j  
@Service  
public class SeckillServiceImpl implements ISeckillService {  
  
    /*  
        秒杀业务中使用Redis判断是否有库存，和用户是否重复购买  
        这些操作都是操作数值，所以使用能够在Redis内部操作数值的对象  
     */    
    @Autowired  
    private StringRedisTemplate stringRedisTemplate;  
    // 需要dubbo调用mall-order模块生成订单的方法  
    @DubboReference  
    private IOmsOrderService dubboOrderService;  
    // 业务中需要使用RabbitMQ消息队列来发送消息实现记录秒杀成功信息  
    @Autowired  
    private RabbitTemplate rabbitTemplate;  
  
    /*  
        1. 判断用户是否为重复购买和Redis中该Sku是否有库存  
        2. 秒杀订单转换成普通订单,需要使用dubbo调用order模块的生成订单方法  
        3. 使用消息队列(RabbitMQ)将秒杀成功记录信息保存到success表中  
        4. 秒杀订单信息返回。  
     */    
    @Override  
    public SeckillCommitVO commitSeckill(SeckillOrderAddDTO seckillOrderAddDTO) {  
        // 第一步：判断用户是否为重复购买和Redis中该Sku是否有库存  
  
        // 从Spring Security上下文中获取userId  
        Long userId = GetUserInfo.getUserId();  
        // 从方法参数中的订单项属性中获得skuId  
        Long skuId = seckillOrderAddDTO.getSeckillOrderItemAddDTO().getSkuId();  
        /*  
            我们要判断当前用户是否秒杀购买过这个商品，要判断用户userId和skuId  
            某个用户某件商品只能购买一次，使用userId和skuId生成一个Key  
            mall:seckill:reseckill:2:1         
        */        
	    String reSeckillCheckKey = SeckillCacheUtils.getReseckillCheckKey(skuId, userId);  
  
        /*  
            确定了上面的key之后，用这个key向Redis发送一个increment指令  
            这个指令是StringRedisTemplate对象特有的，意思是增长，它的效果如下：  
            1.如果这个key不存在，redis会创建这个key，并且值为1保存。  
            2.如果这个key存在，redis会在这个key当前的值基础上加1保存。例如先是1，就会变成2。  
            3.无论key是否存在，这个increment方法都会返回这个key最后的值。  
            所以只要调用increment方法返回值为1，就表示当前用户没有购买过这个商品  
         */        
        Long seckillTimes = stringRedisTemplate.boundValueOps(reSeckillCheckKey).increment();  
        // 判断是否重复购买，即返回值secill是否大于1  
        if (seckillTimes > 1) {  
            // 已经购买过了，抛出异常，终止程序  
            String message = "您已经购买过这个商品了，谢谢您的支持";  
            log.warn(message);  
            throw new CoolSharkServiceException(ResponseCode.FORBIDDEN, message);  
        }  
  
        // 程序运行到此处，表示用户确实是第一次购买该商品  
  
        /*  
            下面要判断这个商品是否还有库存  
            根据要购买商品的skuId，从预热(Redis)的库存数中，获取库存信息  
         */        
        // mall:seckill:sku:stock:1        
	    String skuStockKey = SeckillCacheUtils.getStockKey(skuId);  
        // 如果Redis中没有这个key，就要抛出异常  
        if (!stringRedisTemplate.hasKey(skuStockKey)) {  
            throw new CoolSharkServiceException(ResponseCode.INTERNAL_SERVER_ERROR, "没有该商品的缓存信息(可能在真空期，等下一分钟再试)");  
        }  
        /*  
            下面针对这个key进行库存的减少，使用和increment相反功能的decrement方法  
            所以decrement方法的功能就是将当前库存数-1后返回。  
            绝对不会有多线程问题（天生单线程）  
            leftStock时库存数-1后，剩余的库存数。  
            leftStock为0时，表示当前用户买到了最后一个库存，只有小于0时，才是库存不足  
         */        
        Long leftStock = stringRedisTemplate.boundValueOps(skuStockKey).decrement();  
        if (leftStock < 0) {  
            // 库存不足，抛出异常，终止程序  
            // 但是上面代码中已经记录了当前用户购买当前商品的次数，所以将reSeckillCheckKey恢复为0，才不影响用户下次购买  
            stringRedisTemplate.boundValueOps(reSeckillCheckKey).decrement();  
  
            throw new CoolSharkServiceException(ResponseCode.BAD_REQUEST, "对不起，您要购买的商品已经售罄");  
        }  
  
        // 到此为止，当前用户通过了重复购买的检查，并且库存还有剩余，可以开始生成订单了！  
  
  
        // 第二步：秒杀订单转换成普通订单，需要使用dubbo调用order模块的生成订单方法  
        OrderAddDTO orderAddDTO = convertSeckillOrderToOrder(seckillOrderAddDTO);  
  
        // 经过转换得到了普通订单对象orderAddDTO，但是还没有给userId赋值  
        orderAddDTO.setUserId(userId);  
  
        // dubbo调用生成订单的方法  
        OrderAddVO orderAddVO = dubboOrderService.addOrder(orderAddDTO);  
  
        /*  
            第三步：使用消息队列(RabbitMQ) 将 秒杀成功记录信息 保存到success表中  
            秒杀成功的信息，需求是记录在数据库中，包含的信息主要是订单项相关的            
            但是这个记录并不是迫切运行的，在服务器忙的高并发环境下，可以延迟运行            
            使用消息队列，实现这个效果，典型的削峰填谷  
         */        
        // 实例化Success对象，然后收集相关信息  
        Success success = new Success();  
  
        // 将订单项的同名属性赋值到success中，大部分属性就被赋值了  
        BeanUtils.copyProperties(  
                seckillOrderAddDTO.getSeckillOrderItemAddDTO(),  
                success);  
        // 经过观察，将差异的属性补全  
        success.setUserId(userId);  
        success.setSeckillPrice(seckillOrderAddDTO.getSeckillOrderItemAddDTO().getPrice());  
        success.setOrderSn(orderAddVO.getSn());  
  
        // success对象赋值完成，发送到RabbitMQ  
        rabbitTemplate.convertAndSend(  
                RabbitMqComponentConfiguration.SECKILL_EX,  
                RabbitMqComponentConfiguration.SECKILL_RK,  
                success);  
        // 消息已发出，本方法无需考虑消息接收的问题  
  
        /*  
            第四步：秒杀订单信息返回  
            当前方法要求返回值类星星为SeckillCommitVO  
            经观察，属性和OrderAddVO完全一致，直接同名属性赋值  
         */        
        SeckillCommitVO commitVO = new SeckillCommitVO();  
        BeanUtils.copyProperties(orderAddDTO, commitVO);  
  
        // 最后别忘了返回  
        return commitVO;  
    }  
  
    // 将秒杀订单转换为普通订单的方法  
    private OrderAddDTO convertSeckillOrderToOrder(SeckillOrderAddDTO seckillOrderAddDTO) {  
  
        // 实例化普通订单对象  
        OrderAddDTO orderAddDTO = new OrderAddDTO();  
  
        // 秒杀订单中包含除订单项之外的所有信息，直接同名属性赋值  
        BeanUtils.copyProperties(seckillOrderAddDTO, orderAddDTO);  
  
        // 赋值之后就剩下订单项没有值了  
        /*  
            orderAddDTO的订单项是OrderItemAddDTO的集合  
            seckillOrderAddDTO的订单项是seckillOrderItemAddDTO的对象  
            所以我们需要先将seckillOrderItemAddDTO转换为OrderItemAddDTO  
         */        
        // 先实例化普通订单项  
        OrderItemAddDTO orderItemAddDTO = new OrderItemAddDTO();  
        // 经过观察秒杀订单项也是包含所有普通订单项需要的信息，直接赋值  
        BeanUtils.copyProperties(  
                seckillOrderAddDTO.getSeckillOrderItemAddDTO(),  
                orderItemAddDTO);  
        // 现在我们普通订单和普通订单项都有了正确的属性值  
  
        // 下面要将订单项新增到普通订单的订单项集合中  
        // 先实例化订单项集合对象  
        List<OrderItemAddDTO> list = new ArrayList<>();  
        // 将转换好的订单项添加到这个集合中  
        list.add(orderItemAddDTO);  
        // 将list赋值到普通订单对象的订单项集合中  
        orderAddDTO.setOrderItems(list);  
		
        // 转换完成！返回赋好值的订单对象
        return orderAddDTO;
    }
}
```


### 1. 判断 **用户是否为重复购买** 和 **该Sku是否有库存**

![[秒杀中，判断用户是否重复购买.png]]

这些操作都是操作数值，所以*使用能够在Redis内部操作数值的对象*。

**StringRedisTemplate的指令：**
- `increment([int])`：这个指令是StringRedisTemplate对象特有的，意思是 **增长**，它的效果如下：
    1. 如果这个key *不存在*，redis会创建这个key，并且 *值为1保存*。
    2. 如果这个key *存在*，redis会在这个key*当前的值基础上加1保存*。
        - 例如先是1，就会变成2。
    3. *无论key是否存在*，这个increment方法 *都会返回这个key最后的值*。
    - 所以只要调用increment方法返回值为1，就表示当前用户没有购买过这个商品。

- `decrement([int])`：和increment相反功能的decrement方法，即**减少**。
    - 将当前*库存数-1后返回*。
    - 返回值为0时，表示该用户买到了最后一个商品，所以只有小于0时，才是库存不足。

```java
public SeckillCommitVO commitSeckill(SeckillOrderAddDTO seckillOrderAddDTO) {  
    // 第一步：判断用户是否为重复购买和Redis中该Sku是否有库存  
  
    // 从Spring Security上下文中获取userId  
    Long userId = GetUserInfo.getUserId();  
    // 从方法参数中的订单项属性中获得skuId  
    Long skuId = seckillOrderAddDTO.getSeckillOrderItemAddDTO().getSkuId();  
    /*  
        我们要判断当前用户是否秒杀购买过这个商品，要判断用户userId和skuId  
        某个用户某件商品只能购买一次，使用userId和skuId生成一个Key  
        mall:seckill:reseckill:2:1     
    */    
	String reSeckillCheckKey = SeckillCacheUtils.getReseckillCheckKey(skuId, userId);  
  
    /*  
        确定了上面的key之后，用这个key向Redis发送一个increment指令  
        这个指令是StringRedisTemplate对象特有的，意思是增长，它的效果如下：  
        1.如果这个key不存在，redis会创建这个key，并且值为1保存。
        2.如果这个key存在，redis会在这个key当前的值基础上加1保存。例如先是1，就会变成2。
        3.无论key是否存在，这个increment方法都会返回这个key最后的值。
        所以只要调用increment方法返回值为1，就表示当前用户没有购买过这个商品。
     */    
    Long seckillTimes = stringRedisTemplate.boundValueOps(reSeckillCheckKey).increment();  
    // 判断是否重复购买，即返回值secill是否大于1  
    if (seckillTimes > 1) {  
        // 已经购买过了，抛出异常，终止程序  
        String message = "您已经购买过这个商品了，谢谢您的支持";  
        log.warn(message);  
        throw new CoolSharkServiceException(ResponseCode.FORBIDDEN, message);  
    }  
  
    // 程序运行到此处，表示用户确实是第一次购买该商品  
  
    /*  
        下面要判断这个商品是否还有库存  
        根据要购买商品的skuId，从预热(Redis)的库存数中，获取库存信息  
     */    
    // mall:seckill:sku:stock:1    
	String skuStockKey = SeckillCacheUtils.getStockKey(skuId);  
    // 如果Redis中没有这个key，就要抛出异常  
    if (!stringRedisTemplate.hasKey(skuStockKey)) {  
        throw new CoolSharkServiceException(ResponseCode.INTERNAL_SERVER_ERROR, "没有该商品的缓存信息(可能在真空期，等下一分钟再试)");  
    }  
    /*  
        下面针对这个key进行库存的减少，使用和increment相反功能的decrement方法  
        所以decrement方法的功能就是将当前库存数-1后返回。  
        绝对不会有多线程问题（天生单线程）  
        leftStock是库存数-1后，剩余的库存数。  
        leftStock为0时，表示当前用户买到了最后一个库存，只有小于0时，才是库存不足
     */    
    Long leftStock = stringRedisTemplate.boundValueOps(skuStockKey).decrement();  
    if (leftStock < 0) {  
        // 库存不足，抛出异常，终止程序  
        // 但是上面代码中已经记录了当前用户购买当前商品的次数，所以将reSeckillCheckKey恢复为0，才不影响用户下次购买  
        stringRedisTemplate.boundValueOps(reSeckillCheckKey).decrement();  
  
        throw new CoolSharkServiceException(ResponseCode.BAD_REQUEST, "对不起，您要购买的商品已经售罄");  
    }  
  
    // 到此为止，当前用户通过了重复购买的检查，并且库存还有剩余，可以开始生成订单了！  
	// 其他代码略。。。
    return null;
}
```


### 2. **秒杀订单 转换 成普通订单**，需要使用dubbo调用order模块的生成订单方法。

![[秒杀订单转换成普通订单.png]]

在类中单独定义一个方法来进行 秒杀订单 转换 成普通订单

```java
public SeckillCommitVO commitSeckill(SeckillOrderAddDTO seckillOrderAddDTO) {  
	// 其他代码不关心。。。

    // 到此为止，当前用户通过了重复购买的检查，并且库存还有剩余，可以开始生成订单了！  
    // 第二步：秒杀订单转换成普通订单，需要使用dubbo调用order模块的生成订单方法  
    OrderAddDTO orderAddDTO = convertSeckillOrderToOrder(seckillOrderAddDTO);  
	
	// 经过转换得到了普通订单对象orderAddDTO，但是还没有给userId赋值  
	orderAddDTO.setUserId(userId);  
	  
	// dubbo调用生成订单的方法  
	OrderAddVO orderAddVO = dubboOrderService.addOrder(orderAddDTO);
	
    return null;  
}

// 将秒杀订单转换为普通订单的方法  
private OrderAddDTO convertSeckillOrderToOrder(SeckillOrderAddDTO seckillOrderAddDTO) {  
  
    // 实例化普通订单对象  
    OrderAddDTO orderAddDTO = new OrderAddDTO();  
  
    // 秒杀订单中包含除订单项之外的所有信息，直接同名属性赋值  
    BeanUtils.copyProperties(seckillOrderAddDTO, orderAddDTO);  
  
    // 赋值之后就剩下订单项没有值了  
    /*  
        orderAddDTO的订单项是OrderItemAddDTO的集合  
        seckillOrderAddDTO的订单项是seckillOrderItemAddDTO的对象  
        所以我们需要先将seckillOrderItemAddDTO转换为OrderItemAddDTO  
     */    
    // 先实例化普通订单项  
    OrderItemAddDTO orderItemAddDTO = new OrderItemAddDTO();  
    // 经过观察秒杀订单项也是包含所有普通订单项需要的信息，直接赋值  
    BeanUtils.copyProperties(  
            seckillOrderAddDTO.getSeckillOrderItemAddDTO(),  
            orderItemAddDTO);  
    // 现在我们普通订单和普通订单项都有了正确的属性值  
  
    // 下面要将订单项新增到普通订单的订单项集合中  
    // 先实例化订单项集合对象  
    List<OrderItemAddDTO> list = new ArrayList<>();  
    // 将转换好的订单项添加到这个集合中  
    list.add(orderItemAddDTO);  
    // 将list赋值到普通订单对象的订单项集合中  
    orderAddDTO.setOrderItems(list);  
  
    // 转换完成！返回赋好值的订单对象  
    return orderAddDTO;  
}
```


### 3. **使用消息队列(RabbitMQ)** 将 *秒杀成功记录信息* 保存到success表中

秒杀成功的信息，需求是 *记录在数据库中*，包含的信息主要是订单项相关的。

但是这个记录*并不是迫切运行*的，在*服务器忙的高并发环境下*，*可以延迟运行*。
使用消息队列，实现这个效果，*典型的削峰填谷*

```java
public SeckillCommitVO commitSeckill(SeckillOrderAddDTO seckillOrderAddDTO) {  

	// 其他代码不关心

    /*  
        第三步：使用消息队列(RabbitMQ) 将 秒杀成功记录信息 保存到success表中  
        秒杀成功的信息，需求是记录在数据库中，包含的信息主要是订单项相关的        
        但是这个记录并不是迫切运行的，在服务器忙的高并发环境下，可以延迟运行        
        使用消息队列，实现这个效果，典型的削峰填谷  
     */    
    // 实例化Success对象，然后收集相关信息  
    Success success = new Success();  
  
    // 将订单项的同名属性赋值到success中，大部分属性就被赋值了  
    BeanUtils.copyProperties(  
            seckillOrderAddDTO.getSeckillOrderItemAddDTO(),  
            success);  
    // 经过观察，将差异的属性补全  
    success.setUserId(userId);success.setSeckillPrice(seckillOrderAddDTO.getSeckillOrderItemAddDTO().getPrice());  
    success.setOrderSn(orderAddVO.getSn());  
  
    // success对象赋值完成，发送到RabbitMQ  
    rabbitTemplate.convertAndSend(  
            RabbitMqComponentConfiguration.SECKILL_EX,  
            RabbitMqComponentConfiguration.SECKILL_RK,  
            success);  
    // 消息已发出，本方法无需考虑消息接收的问题  
  
    /*  
        第四步：秒杀订单信息返回  
        当前方法要求返回值类星星为SeckillCommitVO  
        经观察，属性和OrderAddVO完全一致，直接同名属性赋值  
     */    
    SeckillCommitVO commitVO = new SeckillCommitVO();  
    BeanUtils.copyProperties(orderAddDTO, commitVO);  
  
    // 最后别忘了返回  
    return commitVO;  
}
```


### 4. 秒杀订单信息返回
```java
public SeckillCommitVO commitSeckill(SeckillOrderAddDTO seckillOrderAddDTO) {  

	// 其他代码不关心
  
    /*  
        第四步：秒杀订单信息返回  
        当前方法要求返回值类星星为SeckillCommitVO  
        经观察，属性和OrderAddVO完全一致，直接同名属性赋值  
     */    
    SeckillCommitVO commitVO = new SeckillCommitVO();  
    BeanUtils.copyProperties(orderAddDTO, commitVO);  
  
    // 最后别忘了返回  
    return commitVO;  
}
```




## 开发控制层  
  
随机码判断流程：

![[随机码判断流程.png]]
  
controller包下创建 *SeckillController*：
```java
/**  
 * 秒杀业务的控制器  
 */  
@Slf4j  
@RestController  
@RequestMapping("/seckill")  
@Api(tags = "执行秒杀模块")  
public class SeckillController {  
  
    @Autowired  
    private ISeckillService seckillService;  
    @Autowired  
    private RedisTemplate redisTemplate;  
  
    @PostMapping("/{randCode}")  
    @ApiOperation("验证随机码并提交秒杀订单")  
    @ApiImplicitParam(name = "randCode", value = "随机码", required = true)  
    @PreAuthorize("hasAuthority('Role_user')")  
    @SentinelResource(value = "秒杀订单提交",  
            blockHandlerClass = SeckillBlockHandler.class, blockHandler = "seckillBlock",  
            fallbackClass = SeckillFallback.class, fallback = "seckillFallback")  
    public JsonResult<SeckillCommitVO> commitSeckill(  
            @PathVariable String randCode,  
            @Validated SeckillOrderAddDTO seckillOrderAddDTO) {  
  
        // 先获取商品的spuId  
        Long spuId = seckillOrderAddDTO.getSpuId();  
        // 然后确定这个spuId对应随机码的key  
        String randCodeKey = SeckillCacheUtils.getRandCodeKey(spuId);  
        // 判断Redis中是否有这个key  
        if (redisTemplate.hasKey(randCodeKey)) {  
            // 如果Redis中有这个key，就要从Redis中取出这个值，和randCode参数对比  
            String redisRandCode = redisTemplate.boundValueOps(randCodeKey).get() + "";  
  
            // 判断redisRandCode和参数randCode  
            if (!redisRandCode.equals(randCode)) {  
                // 若不一致，抛出异常  
                String message = "随机码不正确(实际开发不要给这样的提示(黄牛))";  
                log.warn(message);  
                throw new CoolSharkServiceException(ResponseCode.NOT_FOUND, message);  
            }  
  
            // 程序运行到这，表示两个随机码相同，调用业务逻辑层提交秒杀订单的方法  
            SeckillCommitVO commitVO = seckillService.commitSeckill(seckillOrderAddDTO);  
  
            // 运行完成，返回给前端  
            return JsonResult.ok(commitVO);  
  
        } else {  
            // Redis中没有这个key，直接抛异常  
            String message = "没有找到当前商品的随机码(等下一分钟再试)";  
            log.warn(message);  
            throw new CoolSharkServiceException(ResponseCode.NOT_FOUND, message);  
        }  
  
    }  
  
}
```


## 测试

启动 Nacos / Seata / RabbitMQ / Redis / Sentinel  
项目 Leaf / product / passport / order / seckill  

注意yml配置文件中的RabbitMQ的用户名和密码  
  
如果说已经购买过，就把允许购买的数量 >1 修改为 >100
如果说没有库存，检查数据库库存，也可以把判断库存的if注释掉
  
测试成功即可
还可以测试sentinel的限流
