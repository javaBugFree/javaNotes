
## 缓存预热思路

在 *即将发生* **高并发业务** *之前*，我们*将一些高并发业务中* **需要的数据 保存到Redis** 中，这种操作，就是 **"缓存预热"**，这样发生高并发时，这些数据就可以*直接从Redis中获得*，无需查询数据库了。

我们要 **利用Quartz** *定时的将每个批次的秒杀商品，预热到Redis*。
  
例如每天的 12:00 14:00 16:00 18:00 进行秒杀，
那么就在    11:55 13:55 15:55 17:55 进行预热。
  
我们预热的内容有  
1. （防止超卖）我们预热的内容是将参与秒杀商品的sku查询出来，根据skuid将该商品的*库存*保存在Redis中，
    - 还要注意为了 **预防雪崩**，在向Redis保存数据时，都应该添加 **随机数**。
    - 在向Redis保存数据时，还要注意线程安全问题（防止超卖）。
  
2. (待完善).在秒杀开始前，生成布隆过滤器，访问时先判断布隆过滤器，如果判断商品存在，再继续访问。
  
3. （防黄牛）在秒杀开始之前，生成每个商品对应的随机码，保存在Redis中，随机码可以绑定给有Spu，保存在前端页面，用户提交时，验证随机码的正确性，只有正确的随机码才能购买商品。


## 设置定时任务

### 将库存和随机码保存到Redis  
  
1. 创建Job接口实现类  
  
2. 创建配置类,配置JobDetail和Trigger  
  
在seckill包下创建*timer.job包*
在seckill包下创建*timer.config包*
  
首先我们*编写缓存预热的操作*，在job包下创建*类SeckillInitialJob*：

- **RedisTemplate对象** 在保存数据到Redis时，会 *将数据* 进行 **序列化** 后*再保存*，
    - **好处**：*有效利用空间*，并且java *再读取* 时也有很好的效率。
    - **缺点**：*不能在 Redis内部 对这个数据进行修改*。

- 现在我们需要做的是保存秒杀sku的库存数，这个数据如果也用RedisTemplate保存，就会容易在 **高并发的情况下** 出现 **线程安全问题**，导致商品库存 “*超卖*”：
    - 例如：*线程A* 从Redis中获取库存数后，在java中对库存进行减少，然后再将减少后的库存保存到redis。
        在这期间，如果 *线程B* 再去请求获取库存 得到的 *还是减少前的库存*，会导致库存“超卖”。

- **解决方法**：
	- 就是需要一个能够在Redis内部直接修改数据的操作，避免线程安全问题，从而防止超卖。
    - 使用的就是 *Spring Data redis框架* 提供的 **StringRedisTemplate 类型对象**，它**可以在Redis内部操作修改数据**。
        - StringRedisTemplate *只能* 向Redis中 **保存字符串**，如果*字符串的 内容是数值*，就 *支持数值的增减*，
            - 因为是字符串，就没有序列化的过程，java代码可以直接操作Redis中数值的增减。
            - 修改时使用 `boundValueOps(key)` 的 `increment()` 方法。效果如下：
                1. 如果这个key **不存在**，redis会创建这个key，并且 *值为1保存*。
                2. 如果这个key **存在**，redis会在这个key *当前的值基础上加1保存*。例如先是1，就会变成2。
                3. 无论key是否存在，这个increment方法 *都会返回这个key最后的值*。
                - 所以只要调用increment方法返回值为1，就表示当前用户没有购买过这个商品。
                - 例如：`stringRedisTemplate.boundValueOps(reSeckillCheckKey).increment();`
            - 修改时使用 `boundValueOps(key)` 的 `decrement()` 方法。效果如下：
                - 将当前key的*值-1后返回*。
        - 最后结合Redis内部 *操作数据的线程* **只有一条**的特征（*Redis天生单线程*），就能保证防止超卖了。
    - 如果有多台Redis服务器构建了 **集群**，想保证 *集群的数据同步*，就需要使用 **redission分布式锁**。

```java
/**  
 * Quartz任务类
 * 编写预热操作
 */  
@Slf4j  
public class SeckillInitialJob implements Job {  
  
    // 查询spu相关信息的mapper  
    @Autowired  
    private SeckillSpuMapper seckillSpuMapper;  
    // 查询sku相关信息的mapper  
    @Autowired  
    private SeckillSkuMapper seckillSkuMapper;  
  
    @Autowired  
    private RedisTemplate redisTemplate;  
  
    /*  
        RedisTemplate对象在保存数据到Redis时，会将数据进行序列化后再保存，  
            好处：有效利用空间，并且java再读取时也有很好的效率。  
            缺点：不能在Redis内部对这个数据进行修改。  
        现在我们需要做的是保存秒杀sku的库存数，这个数据如果也用RedisTemplate保存，  
        就会容易在高并发的情况下出现线程安全问题，导致商品库存 “超卖”：  
            线程A从Redis中获取库存数后，在java中对库存进行减少，然后再将减少后的库存返回给redis  
            在这期间，如果线程B再去请求获取库存就还是减少前的库存，会导致库存“超卖”。  
        解决方法：            
	        就是需要一个能够在Redis内部直接修改数据的操作，避免线程安全问题，从而防止超卖。  
            使用的就是Spring Data redis框架提供的 StringRedisTemplate类型对象，它可以在Redis内部操作修改数据。  
            StringRedisTemplate只能向Redis中保存字符串，如果字符串的内容是数值，就支持数值的增减，  
                因为是字符串，就没有序列化的过程，java代码可以直接操作Redis中数值的增减。  
            最后结合Redis内部操作数据线程只有一条的特征（Redis天生单线程），就能保证防止超卖了。  
            如果有多台Redis服务器构建了集群，想保证集群的数据同步，就需要使用redisson分布式锁。  
     */    
     // 装配能够在redis中直接进行数据增减操作的对象，防止超卖的发生  
    @Autowired  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Override  
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {  
  
        // 目标是将 sku的库存数 和 随机码 预热到redis中  
        
        // 当前方法运行时，是秒杀开始前5分钟，所以我们创建一个5分钟后，也就是开始秒杀时间  
        LocalDateTime time = LocalDateTime.now().plusMinutes(5);  
        // 用上面5分钟后的时间，去查询正在秒杀的商品  
        List<SeckillSpu> seckillSpus = seckillSpuMapper.findSeckillSpusByTime(time);  
  
        // 遍历当前批次的所有秒杀信息的spu列表  
        for (SeckillSpu spu : seckillSpus) {  
            // 秒杀库存数据保存在sku中的，所以要根据spu的spuId查询sku列表  
            List<SeckillSku> seckillSkus = seckillSkuMapper.findSeckillSkusBySpuId(spu.getSpuId());  
            // 遍历seckillSkus集合，从集合中的sku对象中获取库存数，保存到redis  
            for (SeckillSku sku : seckillSkus) {  
                log.info("开始将【{}】号sku库存数保存预热到redis", sku.getSkuId());  
                // 1.要操作Redis，首先要确定这次要操作的key，这些key都是定义好的常量  
                /*  
                    SeckillCacheUtils.getStockKey()就是获取库存常量前缀的方法  
                    方法的参数传入skuId，会追加到常量字符串的最后  
                    最终常量的名称可能为：mall:seckill:sku:stock:1  
                 */                
                String skuStockKey = SeckillCacheUtils.getStockKey(sku.getSkuId());  
                // 2.通常情况下，需要再检查redis中是否已有该key  
                if (redisTemplate.hasKey(skuStockKey)) {  
                    // 如果这个key已经存在，就证明之前已经保存过了，这里只记录日志即可  
                    log.info("【{}】号sku的库存数已经缓存过了", sku.getSkuId());  
                } else {  
                    // 如果这个key不存在，就要将数据库中sku的库存数保存到redis里  
                    stringRedisTemplate.boundValueOps(skuStockKey).set(
		                    // stringRedisTemplate只能保存字符串类型的数据
                            sku.getSeckillStock() + "",  
                            /*  
                                // 保存的时间 = 秒杀持续时间 + 提前的5分钟 + 防雪崩随机数30秒  
                                1000 * 60 * 60 * 2 + 1000 * 60 * 5 + RandomUtils.nextInt(1000 * 30),TimeUnit.MILLISECONDS);
                            */                            
                            // 为了方便测试，保存5分钟  
                            1000 * 60 * 5 + RandomUtils.nextInt(10000),  
                            TimeUnit.MILLISECONDS);  
                    log.info("【{}】号sku库存数成功预热到缓存！", sku.getSkuId());  
                }  
            }  
  
            // 上面是sku的内存循环结束了，但是代码仍然在外层循环中  
  
            /*  
                正在遍历spu对象，我们生成的 随机码 和 spu的Id 关联  
                随机码就是一个随机数，随机范围根据自身需求定义即可  
             */            
            // 操作Redis先确定Key  
            String randCodeKey = SeckillCacheUtils.getRandCodeKey(spu.getSpuId());  
            // 判断这个key是否已经在Redis中  
            if (redisTemplate.hasKey(randCodeKey)) {  
                // 如果当前Redis已经有这个key了，实际开发跳过即可  
                // 但是现在学习测试，需要在秒杀购买业务时，获取这个随机码，所以输出一下  
                int randCode = (int) redisTemplate.boundValueOps(randCodeKey).get();  
                log.info("{}号的spu商品随机码已经缓存了，值为：{}", spu.getSpuId(), randCode);  
            } else {  
                // 如果Redis中没有这个key，就生成随机码保存到Redis  
                // 我们制定一个随机码的范围 100001 ~ 999999                
                int randCode = RandomUtils.nextInt(899999) + 100000;  
                redisTemplate.boundValueOps(randCodeKey).set(  
                        randCode,  
                        // 为了方便测试，保存5分钟  
                        1000 * 60 * 5 + RandomUtils.nextInt(10000),  
                        TimeUnit.MILLISECONDS);  
                log.info("{}号spu商品的随机码已经生成并保存了，值为：{}", spu.getSpuId(), randCode);  
            }  
        }  
  
    }  
}
```


### 配置Quartz触发

上面的类中的代码只是编写了预热操作
  
我们需要在Quartz中配置才能触发生效
  
在timer.config包中创建 *QuartzConfig类* 编写Job的触发：
```java
/**  
 * Quartz配置类
 * 触发生效
 */  
@Configuration  
public class QuartzConfig {  
  
    // 向Spring容器中保存JobDetail对象  
    @Bean  
    public JobDetail initJobDetail() {  
        return JobBuilder.newJob(SeckillInitialJob.class)  
                .withIdentity("initJobDetail")  
                .storeDurably()  
                .build();  
    }  
  
    // 向Spring容器中保存Trigger对象进行触发  
    @Bean  
    public Trigger initTrigger() {  
        // 12:00  14:00  16:00  18:00  进行秒杀，提前五分钟的cron表达式  
        // 0 55 11,13,15,17 * * ?  
        // 学习过程中，为了测试观察效果，我们设计每分钟运行一次  
        CronScheduleBuilder cron = CronScheduleBuilder.cronSchedule("0 0/1 * * * ?");  
        return TriggerBuilder.newTrigger()  
                .withIdentity("initTrigger")  
                .forJob(initJobDetail())  
                .withSchedule(cron)  
                .build();  
    }  
  
}
```


### 测试

启动 Nacos / Redis / Seata  
  
项目启动 seckill  
  
每分钟0秒时，观察日志输出状态
  
**保证数据库中有数据 在秒杀时间段内!!!!!!!**