
front：前台  

在 *csmall-front-webapi项目* 中开发  

无需编写持久层代码，因为 *mall_pms数据库* 的所有操作均在 *product模块* 编写完成了。  
我们 *front模块* **只需dubbo调用** 即可。


## 业务逻辑层

1. 创建*service.impl包*，包中编写业务逻辑层实现类 *FrontCategoryServiceImpl*，实现IFrontCategoryService

![[三级分类树存入到Map的结构.png]]

```java
@Slf4j  
@Service  
public class FrontCategoryServiceImpl implements IFrontCategoryService {  
  
    // Front模块要Dubbo调用product模块的方法，实现查询所有分类信息列表  
    @DubboReference  
    private IForFrontCategoryService dubboCategoryService;  
  
    // 方法要将查询到的分类信息保存到Redis，所以需要操作redis的对象  
    @Autowired  
    private RedisTemplate redisTemplate;  
  
    // 开发时，使用Redis要定义一个常量，作为key的名称，防止编码时拼写错误  
    public static final String CATEGORY_TREE_KEY = "category_tree";  
  
    // 返回三级分类树对象  
	@Override  
	public FrontCategoryTreeVO categoryTree() {  
	  
	    // 方法开始，先检查redis中是否已经包含这个key  
	    if (redisTemplate.hasKey(CATEGORY_TREE_KEY)) {  
	        // 当redis中包含这个key时，从redis中获取对应的值直接返回即可  
	        FrontCategoryTreeVO<FrontCategoryEntity> treeVO;  
	        treeVO = (FrontCategoryTreeVO<FrontCategoryEntity>) redisTemplate.boundValueOps(CATEGORY_TREE_KEY).get();  
	        // 返回  
	        return treeVO;  
	    }  
	  
	    /*  
	        Redis中没有三级分类树信息，表示本次请求可能是第一次访问  
	        这样就需要从数据库查询所有分类信息，构建为三级分类树信息，再保存到Redis  
	        利用dubbo调用product模块查询所有分类信息的功能  
	     */    List<CategoryStandardVO> categoryList = dubboCategoryService.getCategoryList();  
	  
	    /*  
	        上面查询到的categoryList就包含了所有的分类信息  
	        下面要将分类信息按照级别构建成分类树，需要一个能够包含保存子分类集合属性(children属性) 的类  
	        FrontCategoryEntity这个类就是包含 分类基本属性和子分类集合属性的实体类  
	        因为转换过程比较复杂，所以单独编写一个方法实现转换  
	     */    
	    FrontCategoryTreeVO<FrontCategoryEntity> treeVO = initTree(categoryList);  
	    // 上面方法完成了三级分类树的构建，返回了treeVO  
	  
	    // 下面要将treeVO保存到Redis，方便后面请求获取  
	    redisTemplate.boundValueOps(CATEGORY_TREE_KEY).set(  
	            treeVO,  
	            1,  
	            TimeUnit.MINUTES  
	    );  
	    // 上面设置了redis中数据有效期，学习和测试过程中不要设置太长，这里1分钟即可  
	    // 实际开发中要设置时间比较长，例如24小时甚至更长  
	  
	    // 返回treeVO！  
	    return treeVO;  
	}  
	  
	private FrontCategoryTreeVO<FrontCategoryEntity> initTree(List<CategoryStandardVO> categoryList) {  
	    /*  
	        第一步：  
	        确定所有分类的父分类id  
	        创建一个map  
	        以父分类id为key，将当前正在遍历的分类对象，保存在对应的value中  
	     */    
	    Map<Long, List<FrontCategoryEntity>> map = new HashMap<>();  
	  
	    log.info("准备开始构建三级分类树，分类树元素总数：{}", categoryList.size());  
	    // 遍历数据库查询出来的所有分类对象集合  
	    for (CategoryStandardVO standardVO : categoryList) {  
	        // 当前正在遍历的standardVO对象，没有childrens属性，需要转换为有childrens属性的FrontCategoryEntity  
	        FrontCategoryEntity frontCategoryEntity = new FrontCategoryEntity();  
	        // 将categoryStandardVO同名属性赋值到frontCategoryEntity对象  
	        BeanUtils.copyProperties(standardVO, frontCategoryEntity);  
	  
	        // 因为后面会多次使用到父分类id，所以这里提取出来  
	        Long parentId = frontCategoryEntity.getParentId();  
	  
	        // 判断map中是否已存在这个父分类id作为key的元素  
	        if (!map.containsKey(parentId)) {  
	            /*  
	                如果map中没有这个key，表示当前分类对象的父分类id第一次出现，  
	                要在map中新增个元素，key就是这个父分类id，元素的值是个list要实例化  
	             */            
	            List<FrontCategoryEntity> value = new ArrayList<>();  
	            // 将当前分类对象保存到这个list中  
	            value.add(frontCategoryEntity);  
	            // 最后将key和value组合保存到Map  
	            map.put(parentId, value);  
	        } else {  
	            /*  
	                如果map中已经存在当前分类对象的父分类id为key的元素，  
	                我们就直接获取这个key的value，在value中添加当前分类对象。  
	             */            
	            // 引用类型，直接添加即可，map中对应的该list也会增加  
		        map.get(standardVO.getParentId()).add(frontCategoryEntity);  
	        }  
	    }  
	  
	    /*  
	        第二步：  
	        构建三级分类树，将子分类对象集合添加到对应的父分类对象的children属性中  
	        先从所有的一级分类对象开始，也就是父分类id为0的对象  
	     */    
	    // 一级分类的父级id，没有父类，所以就是0。  
	    Long firstLevelParentId = 0L;  
	    List<FrontCategoryEntity> firstLevels = map.get(firstLevelParentId);  
	  
	    // 判断 firstLevel 是否为 null 或 元素个数为0，抛出异常终止程序  
	    if (firstLevels == null || firstLevels.isEmpty()) {  
	        String message = "数据异常，没有一级分类对象！";  
	        log.warn(message);  
	        throw new CoolSharkServiceException(ResponseCode.INTERNAL_SERVER_ERROR, message);  
	    }  
	  
	    // 遍历一级分类集合  
	    for (FrontCategoryEntity oneLevel : firstLevels) {  
	  
	        // 一级分类的id 就是 二级分类的父id，  
	        Long secondLevelParentId = oneLevel.getId();    // oneLevel.getId()!!!!!!!  
	        // 根据一级分类的id 获取 二级分类的对象集合。  
	        List<FrontCategoryEntity> secondLevels = map.get(secondLevelParentId);  
	        // 判断二级分类集合是否为null或空  
	        if (secondLevels == null || secondLevels.isEmpty()) {  
	            // 二级分类集合缺失，不用抛出异常，只需在日志输出警告即可  
	            log.warn("当前二级分类没有内容：{}", secondLevelParentId);  
	  
	            // 该一级分类下无二级分类，无需运行循环后面的语句，直接进入下次循环  
	            continue;  
	        }  
	  
	        // 二级分类集合确认有元素，进行遍历  
	        for (FrontCategoryEntity twoLevel : secondLevels) {  
	              
	            // 获取当前二级分类的id，做为三级分类的父id  
	            Long thirdLevelParentId = twoLevel.getId();  
	            // 根据二级分类的id获取三级分类的对象集合  
	            List<FrontCategoryEntity> thirdLevels = map.get(thirdLevelParentId);  
	            // 判断三级分类集合是否为null或空  
	            if (thirdLevels == null || thirdLevels.isEmpty()) {  
	                log.warn("当前二级分类没有三级分类内容：{}", thirdLevelParentId);  
	  
	                continue;  
	            }  
	  
	            // 三级分类集合至少有一个元素，将它赋值给二级分类的children属性  
	            twoLevel.setChildrens(thirdLevels);  
	        }  
	  
	        /*  
	            在内层循环结束后，在外层循环结束前  
	            将二级分类集合赋值给一级分类对象的children属性  
	         */        
	        oneLevel.setChildrens(secondLevels);  
	    }  
	  
	    /*  
	        在循环结束后，我们所有的分类对象都已经保存在了自己对应的父类对象的children属性中了，  
	        但是我们最终返回的是FirstCategoryTreeVO类型  
	        将一级分类对象集合，保存到FirstCategoryTreeVO类型中，返回  
	     */    
	    FrontCategoryTreeVO<FrontCategoryEntity> treeVO = new FrontCategoryTreeVO<>();  
	    treeVO.setCategories(firstLevels);  
	  
	    // 返回treeVO  
	    return treeVO;  
	}  
  
}
```


递归实现文章：
https://www.yht7.com/news/127281


## 控制层

创建控制层controller包  
  
*CategoryController类*：
```java
@Slf4j  
@RestController  
@RequestMapping("/front/category")  
@Api(tags = "前台分类查询")  
public class CategoryController {  
  
    @Autowired  
    private IFrontCategoryService categoryService;  
  
    @GetMapping("/all")  
    @ApiOperation("查询获取三级分类树对象")  
    public JsonResult<FrontCategoryTreeVO<FrontCategoryEntity>> getTreeVO() {  
        FrontCategoryTreeVO<FrontCategoryEntity> treeVO = categoryService.categoryTree();  
        return JsonResult.ok(treeVO);  
    }  
  
}
```


## 测试

启动nacos / seata / redis  
  
先启动生产者product / 后启动消费者front  
  
访问  
localhost:10004/doc.html