
Spring Boot 框架下使用 Quartz 格式还是非常固定的，
我们选用之前学习微服务的项目*csmall*，减少对大项目的影响。


1. 首先 *添加依赖*
我们选择 **csmall-stock-webapi模块** 的 *pom.xml文件*：
```xml
<!-- Spring Boot整合Quartz的依赖 -->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-quartz</artifactId>  
</dependency>
```


2. 先编写要执行的任务
当前项目模块中 *创建quartz包*，
包中创建一个 *QuartzJob* 的类，*实现Job接口*：
```java
/**  
 * Quartz要执行的任务  
 */  
@Slf4j  
public class QuartzJob implements Job {  
  
    @Override  
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {  
        // 当前Job实现类只是为了测试Quartz的调用效果，所以操作尽量简单，这里只是输出时间  
        log.info("------当前时间为:【{}】-------", LocalDateTime.now());  
    }  
}
```


3. *创建配置类*，**封装JobDetail对象**，**设置运行时机**，**并把它们保存在Spring容器中**。

上面编写的是Job接口的实现类，要想运行还需要将它 *封装为* **JobDetail对象** *保存在Spring容器*中；
还有要 *创建*一个 **Trigger** 设置要 **运行的时机**，*也保存到Spring容器* 中；
在*quartz包下*，*再创建* 一个 **QuartzConfiguration类**，其中 **编写它们的调度绑定关系**。

这个*格式是固定的*，后面再需要绑定，直接套用即可。
```java
/**  
 * Quartz（任务调度器）的配置类  
 * <p>  
 * 用于绑定 Job 和 Trigger 的触发关系  
 * 这个触发实际上会由 Scheduler 来调度，但是这个对象已经被 Spring Boot 管理了  
 * 我们只需要编写将 JobDetail 和 Trigger 对象保存到 SpringIOC容器 中即可。  
 */  
@Configuration  
public class QuartzConfiguration {  
  
    // SpringBoot启动时，使用@Bean注解标记的方法，方法的 返回值 会自动保存到Spring容器中  
    @Bean  
    public JobDetail showTime() {  
        // JobDetail 对象中配置要运行的Job实现类信息  
  
        // JobBuilder.newJob这个方法就是 会关联Job实现类 的方法  
        return JobBuilder.newJob(QuartzJob.class)  
                // 给当前任务起名，多个任务名称不要有重复  
                .withIdentity("showTime")  
                /*  
                    在SpringBoot默认环境下，JobDetail对象如果没有触发器绑定，可能会被GC回收  
                    设置storeDurably()方法后，JobDetail对象即使没有被绑定，也不会被回收  
                 */                
                .storeDurably()  
                .build();  
    }  
  
  
    // 使用@Bean注解，将触发器对象Trigger对象也保存到Spring容器中  
    @Bean  
    public Trigger showTimeTrigger() {  
        // Trigger最重要的就是Cron表达式  
        // 声明Cron表达式，确定这个触发的时间  
        CronScheduleBuilder cron = CronScheduleBuilder.cronSchedule("0 33 10 4 4 ?");  
  
        return TriggerBuilder.newTrigger()  
                // 指定要触发的JobDetail对象  
                .forJob(showTime())  
                // 绑定Cron表达式  
                .withSchedule(cron)  
                // 给当前触发器起名，也是不要和其他触发器名称重复  
                .withIdentity("showTimeTrigger")  
                .build();  
    }  
  
}
```

Nacos / Seata需要启动
其他服务和软件都可以关闭

然后启动csmall-stock-webapi模块
观察控制台输出



## 练习

csmall-stock模块，

实现每隔20秒对当前数据库库存表中的某个商品(PU201)
库存数减少2的操作，同时在日志中输出"库存减少完成"

并观察数据库库存数是否变化

1. 创建要执行的任务
```java
@Slf4j  
public class StockJob implements Job {  
  
    @Autowired  
    private StockService stockService;  
  
    // 每隔20秒运行一次减少库存  
    @Override  
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {  
        stockService.reduceStockCount(new StockReduceCountDTO().setCommodityCode("PU201").setReduceCount(10));  
        log.info("库存减少成功");  
    }  
}
```

2. *创建配置类*，**封装JobDetail对象**，**设置运行时机**，**并把它们保存在Spring容器中**。
```java
// 每个20秒减少一次库存  
@Bean  
public JobDetail reduceStock() {  
    return JobBuilder.newJob(StockJob.class)  
            .withIdentity("reduceStock")  
            .storeDurably()  
            .build();  
}  
  
@Bean  
public Trigger reduceStockTrigger() {  
    CronScheduleBuilder cron = CronScheduleBuilder.cronSchedule("0/20 * * * * ?");  
  
    return TriggerBuilder.newTrigger()  
            .forJob(reduceStock())  
            .withSchedule(cron)  
            .withIdentity("reduceStockTrigger")  
            .build();  
}
```
